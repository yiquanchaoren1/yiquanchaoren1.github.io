<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>project22_分块demo测试</title>
    <link href="/2025/03/07/project22/"/>
    <url>/2025/03/07/project22/</url>
    
    <content type="html"><![CDATA[<p>网格有多大呢，按照整个大网格进行划分，按照一个方向划分4块，然后每一块中设置halo区，进行不同卡间的数据交换。要处理的是7点stencil计算</p><p><img src="C:\Users\bing\AppData\Roaming\Typora\typora-user-images\1740295068447.png" alt="1740295068447"></p><p>设备间能进行点对点的通信吗？能，demo能通过</p><p>迭代是怎么迭代的</p><p>验证和什么验证的</p><p>拷贝回去的时候halo区的数据拷贝了吗</p><p>思路：在z方向上分4块，将要计算的数据分块传输到每一块中，每一块中设置halo区，用于边界点的计算。<br>计算需要用到的一些数组，每一次迭代的时候都要传入每一个块中，只传递每一块中需要用到的数据。</p><p>2025年3月2日17:02:32</p><p>halo区是不是通信少了两次，加上了。</p><p>不要全设置1，需要更有说服力的数据计算。更改数据后，出现了错误。。。</p><p>2025年3月3日15:15:14</p><p>将原数组的值设置为不同的值，更有说服力，先halo通信然后计算，最后将计算后的数据传回进行总体验证，验证正确。</p><p>研究代码中的下标对应关系，然后进行多次迭代demo的编写，并验证。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">按照下面的逻辑更改代码，下面的逻辑是不是才是对的<br>设备 0：<br><br>发送：有效区域底部 → 设备<span class="hljs-number"> 1 </span>的上方 Halo 区。<br>接收：设备<span class="hljs-number"> 1 </span>的有效区域顶部 → 下方 Halo 区。<br>设备 3：<br><br>发送：有效区域顶部 → 设备<span class="hljs-number"> 2 </span>的下方 Halo 区。<br>接收：设备<span class="hljs-number"> 2 </span>的有效区域底部 → 上方 Halo 区。<br>设备<span class="hljs-number"> 1 </span>和 2：<br><br>发送：有效区域底部 → 下游设备的上方 Halo 区。<br>发送：有效区域顶部 → 上游设备的下方 Halo 区。<br>接收：上游设备的有效区域底部 → 上方 Halo 区。<br>接收：下游设备的有效区域顶部 → 下方 Halo 区。<br></code></pre></td></tr></table></figure><p>按照这个逻辑通过了。</p><p>stencil计算是不是 不用计算周围边界的值。 不用，所以之前计算失败是因为计算了边界的值。而在cpu上没有计算。</p><p>2025年3月7日11:02:38</p><p>不用开启p2p通信，默认好像是开启的</p><p>每个设备只接收数据到halo区即可，不用发送</p><p>demo测试完毕</p><h2 id="demo调试"><a href="#demo调试" class="headerlink" title="demo调试"></a>demo调试</h2><p>以下是为您添加详细注释的完整Demo代码，关键部分使用中文注释说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 基于HIP+OpenMP的多卡并行三维Stencil计算Demo</span><br><span class="hljs-comment"> * 功能：在4个DCU卡上并行执行7点Stencil计算，包含Halo区交换和结果验证</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br>·<br><span class="hljs-comment">// 定义网格参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 64       <span class="hljs-comment">// X维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 64       <span class="hljs-comment">// Y维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 64       <span class="hljs-comment">// Z维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALO 1      <span class="hljs-comment">// Halo区层数（7点Stencil需要1层）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_DEVICES 4 <span class="hljs-comment">// 使用的DCU卡数量</span></span><br><br><span class="hljs-comment">// HIP错误检查宏（每个HIP API调用后都应使用此宏检查）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIP_CHECK(cmd) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    hipError_t <span class="hljs-keyword">error</span> = cmd; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">error</span> != hipSuccess) &#123; \</span><br><span class="hljs-meta">        std::cerr &lt;&lt; <span class="hljs-string">&quot;HIP错误: &quot;</span> &lt;&lt; hipGetErrorString(<span class="hljs-keyword">error</span>) \</span><br><span class="hljs-meta">                  &lt;&lt; <span class="hljs-string">&quot; 文件: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot; 行号: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl; \</span><br><span class="hljs-meta">        exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">    &#125; \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 7点Stencil计算核函数</span><br><span class="hljs-comment"> * @param data    输入数据指针</span><br><span class="hljs-comment"> * @param new_data 输出数据指针</span><br><span class="hljs-comment"> * @param local_nz 当前设备处理的Z轴总层数（含Halo）</span><br><span class="hljs-comment"> * @param dev_id   设备ID（用于调试输出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">stencil7pt_kernel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span>* data, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span>* new_data, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> local_nz, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> dev_id)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 计算全局线程索引（跳过Halo区）</span><br>    <span class="hljs-type">int</span> z = blockIdx.z * blockDim.z + threadIdx.z + HALO;<br>    <span class="hljs-type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y + HALO;<br>    <span class="hljs-type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x + HALO;<br>    <br>    <span class="hljs-comment">// 检查是否在有效计算区域内</span><br>    <span class="hljs-keyword">if</span> (x &lt; NX-HALO &amp;&amp; y &lt; NY-HALO &amp;&amp; z &lt; (local_nz-HALO)) &#123;<br>        <span class="hljs-comment">// 计算一维索引（行优先存储）</span><br>        <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br>        <br>        <span class="hljs-comment">// 7点Stencil计算：中心点与六个相邻点平均</span><br>        new_data[idx] = (data[idx]           <span class="hljs-comment">// 中心点</span><br>                       + data[idx + <span class="hljs-number">1</span>]       <span class="hljs-comment">// x+1方向</span><br>                       + data[idx - <span class="hljs-number">1</span>]       <span class="hljs-comment">// x-1方向</span><br>                       + data[idx + NX]      <span class="hljs-comment">// y+1方向 </span><br>                       + data[idx - NX]      <span class="hljs-comment">// y-1方向</span><br>                       + data[idx + NX*NY]   <span class="hljs-comment">// z+1方向</span><br>                       + data[idx - NX*NY]   <span class="hljs-comment">// z-1方向</span><br>                       ) / <span class="hljs-number">7.0</span>;<br><br>        <span class="hljs-comment">// 调试输出：每个设备第一个计算点的值</span><br>        <span class="hljs-keyword">if</span> (x == HALO &amp;&amp; y == HALO &amp;&amp; z == HALO) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device %d: new_data=%.2f\n&quot;</span>, dev_id, new_data[idx]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化主机端数据（全1矩阵）</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">host_data</span><span class="hljs-params">(NX * NY * NZ, <span class="hljs-number">1.0</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> expected_value = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 预期结果（所有输入为1时的平均值）</span><br><br>    <span class="hljs-comment">// 步骤1: 初始化HIP并启用设备间P2P访问</span><br>    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipInit</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id)); <span class="hljs-comment">// 绑定当前线程到指定DCU</span><br>        <br>        <span class="hljs-comment">// 启用设备间的点对点内存访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> peer=<span class="hljs-number">0</span>; peer&lt;NUM_DEVICES; ++peer) &#123;<br>            <span class="hljs-keyword">if</span> (peer != dev_id) &#123;<br>                <span class="hljs-type">int</span> canAccess = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceCanAccessPeer</span>(&amp;canAccess, dev_id, peer));<br>                <span class="hljs-keyword">if</span> (canAccess) &#123;<br>                    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceEnablePeerAccess</span>(peer, <span class="hljs-number">0</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤2: 多卡并行计算（每个OpenMP线程对应一个DCU）</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br>        <br>        <span class="hljs-comment">/* ---------- 数据划分与内存分配 ---------- */</span><br>        <span class="hljs-comment">// 将Z轴划分为4个连续区域（每个设备处理一部分）</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES<span class="hljs-number">-1</span>) ?   <span class="hljs-comment">// 全局结束层</span><br>            total_z : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span>*HALO;  <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-comment">// 设备内存分配（包含Halo区）</span><br>        <span class="hljs-type">double</span> *d_data, *d_new;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_data, NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_new, NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br><br>        <span class="hljs-comment">/* ---------- 数据初始化 ---------- */</span><br>        <span class="hljs-comment">// 主机端缓冲区初始化（包含Halo区，初始值全1）</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">local_host</span><span class="hljs-params">(NX*NY*local_z, <span class="hljs-number">1.0</span>)</span></span>; <br>        <span class="hljs-comment">// 将数据拷贝到设备（含Halo区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            d_data, <br>            local_host.<span class="hljs-built_in">data</span>(), <br>            NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <br>            hipMemcpyHostToDevice<br>        ));<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-comment">// 定义线程块和网格大小</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">// 每个线程块4x4x4线程</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            (NX + block.x - <span class="hljs-number">1</span>) / block.x,        <span class="hljs-comment">// X方向网格数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (NY + block.y - <span class="hljs-number">1</span>) / block.y,        <span class="hljs-comment">// Y方向</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (local_z - <span class="hljs-number">2</span>*HALO + block.z <span class="hljs-number">-1</span>)/block.z <span class="hljs-comment">// Z方向（仅计算有效区域）</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><br>        <span class="hljs-comment">// 创建HIP流（用于异步操作）</span><br>        hipStream_t stream;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamCreate</span>(&amp;stream));<br><br>        <span class="hljs-comment">/* ---------- 核函数执行 ---------- */</span><br>        <span class="hljs-built_in">hipLaunchKernelGGL</span>(<br>            stencil7pt_kernel, <span class="hljs-comment">// 核函数名</span><br>            grid, block,        <span class="hljs-comment">// 网格/线程块配置</span><br>            <span class="hljs-number">0</span>, stream,         <span class="hljs-comment">// 共享内存大小和流</span><br>            d_data, d_new,     <span class="hljs-comment">// 输入输出数据</span><br>            local_z, dev_id    <span class="hljs-comment">// 附加参数</span><br>        );<br>        <br>        <span class="hljs-comment">/* ---------- Halo区数据交换 ---------- */</span><br>        <span class="hljs-comment">// 与相邻设备交换Halo数据（异步操作）</span><br>        <span class="hljs-keyword">if</span>(dev_id &gt; <span class="hljs-number">0</span>) &#123; <br>            <span class="hljs-comment">// 向下游设备（dev_id-1）发送下方Halo数据</span><br>            <span class="hljs-type">double</span>* send_ptr = d_new + HALO*NX*NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z-HALO)*NX*NY, <span class="hljs-comment">// 目标卡的上方Halo区</span><br>                dev_id<span class="hljs-number">-1</span>,                     <span class="hljs-comment">// 目标设备ID</span><br>                send_ptr, dev_id,             <span class="hljs-comment">// 源数据指针和设备ID</span><br>                NX*NY*HALO*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1层Halo）</span><br>                stream<br>            ));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dev_id &lt; NUM_DEVICES<span class="hljs-number">-1</span>) &#123; <br>            <span class="hljs-comment">// 从上游设备（dev_id+1）接收上方Halo数据</span><br>            <span class="hljs-type">double</span>* recv_ptr = d_new + (local_z<span class="hljs-number">-2</span>*HALO)*NX*NY; <span class="hljs-comment">// 本卡下方Halo区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,            <span class="hljs-comment">// 本卡接收地址</span><br>                d_new + HALO*NX*NY,          <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id+<span class="hljs-number">1</span>,                    <span class="hljs-comment">// 源设备ID</span><br>                NX*NY*HALO*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),   <span class="hljs-comment">// 数据大小</span><br>                stream<br>            ));<br>        &#125;<br>        <br>        <span class="hljs-comment">// 等待所有操作完成</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamSynchronize</span>(stream));<br><br>        <span class="hljs-comment">/* ---------- 结果验证 ---------- */</span><br>        <span class="hljs-comment">// 将设备数据拷贝回主机</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            local_host.<span class="hljs-built_in">data</span>(), <br>            d_new,<br>            NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),<br>            hipMemcpyDeviceToHost<br>        ));<br>        <br>        <span class="hljs-comment">// 检查每个点的计算结果</span><br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=HALO; z&lt;local_z-HALO; ++z) &#123;        <span class="hljs-comment">// 遍历有效区域</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=HALO; y&lt;NY-HALO; ++y) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=HALO; x&lt;NX-HALO; ++x) &#123;<br>                    <span class="hljs-type">double</span> val = local_host[z*NX*NY + y*NX + x];<br>                    <span class="hljs-comment">// 允许1e-6的浮点误差</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(val - expected_value) &gt; <span class="hljs-number">1e-6</span>) &#123;<br>                        valid = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical <span class="hljs-comment">// 临界区保护输出</span></span><br>                        &#123;<br>                            std::cerr &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id <br>                                      &lt;&lt; <span class="hljs-string">&quot; 错误 @ (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; z <br>                                      &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; vs &quot;</span> &lt;&lt; expected_value <br>                                      &lt;&lt; std::endl;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 输出验证结果</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> <br>                      &lt;&lt; (valid ? <span class="hljs-string">&quot;✓ 验证通过&quot;</span> : <span class="hljs-string">&quot;✗ 验证失败&quot;</span>) <br>                      &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">/* ---------- 资源释放 ---------- */</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_data));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_new));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamDestroy</span>(stream));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="更正了不同卡需要进行halo区通信的次数"><a href="#更正了不同卡需要进行halo区通信的次数" class="headerlink" title="更正了不同卡需要进行halo区通信的次数"></a>更正了不同卡需要进行halo区通信的次数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 基于HIP+OpenMP的多卡并行三维Stencil计算Demo</span><br><span class="hljs-comment"> * 功能：在4个DCU卡上并行执行7点Stencil计算，包含Halo区交换和结果验证</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 定义网格参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 64       <span class="hljs-comment">// X维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 64       <span class="hljs-comment">// Y维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 64       <span class="hljs-comment">// Z维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALO 1      <span class="hljs-comment">// Halo区层数（7点Stencil需要1层）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_DEVICES 4 <span class="hljs-comment">// 使用的DCU卡数量</span></span><br><br><span class="hljs-comment">// HIP错误检查宏（每个HIP API调用后都应使用此宏检查）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIP_CHECK(cmd) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    hipError_t <span class="hljs-keyword">error</span> = cmd; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">error</span> != hipSuccess) &#123; \</span><br><span class="hljs-meta">        std::cerr &lt;&lt; <span class="hljs-string">&quot;HIP错误: &quot;</span> &lt;&lt; hipGetErrorString(<span class="hljs-keyword">error</span>) \</span><br><span class="hljs-meta">                  &lt;&lt; <span class="hljs-string">&quot; 文件: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot; 行号: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl; \</span><br><span class="hljs-meta">        exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">    &#125; \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 7点Stencil计算核函数</span><br><span class="hljs-comment"> * @param data    输入数据指针</span><br><span class="hljs-comment"> * @param new_data 输出数据指针</span><br><span class="hljs-comment"> * @param local_nz 当前设备处理的Z轴总层数（含Halo）</span><br><span class="hljs-comment"> * @param dev_id   设备ID（用于调试输出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">stencil7pt_kernel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span>* data, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span>* new_data, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> local_nz, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> dev_id)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 计算全局线程索引（跳过Halo区）</span><br>    <span class="hljs-type">int</span> z = blockIdx.z * blockDim.z + threadIdx.z + HALO;<br>    <span class="hljs-type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y + HALO;<br>    <span class="hljs-type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x + HALO;<br>    <br>    <span class="hljs-comment">// 检查是否在有效计算区域内</span><br>    <span class="hljs-keyword">if</span> (x &lt; NX-HALO &amp;&amp; y &lt; NY-HALO &amp;&amp; z &lt; (local_nz-HALO)) &#123;<br>        <span class="hljs-comment">// 计算一维索引（行优先存储）</span><br>        <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br>        <br>        <span class="hljs-comment">// 7点Stencil计算：中心点与六个相邻点平均</span><br>        new_data[idx] = (data[idx]           <span class="hljs-comment">// 中心点</span><br>                       + data[idx + <span class="hljs-number">1</span>]       <span class="hljs-comment">// x+1方向</span><br>                       + data[idx - <span class="hljs-number">1</span>]       <span class="hljs-comment">// x-1方向</span><br>                       + data[idx + NX]      <span class="hljs-comment">// y+1方向 </span><br>                       + data[idx - NX]      <span class="hljs-comment">// y-1方向</span><br>                       + data[idx + NX*NY]   <span class="hljs-comment">// z+1方向</span><br>                       + data[idx - NX*NY]   <span class="hljs-comment">// z-1方向</span><br>                       ) / <span class="hljs-number">7.0</span>;<br><br>        <span class="hljs-comment">// 调试输出：每个设备第一个计算点的值</span><br>        <span class="hljs-keyword">if</span> (x == HALO &amp;&amp; y == HALO &amp;&amp; z == HALO) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device %d: new_data=%.2f\n&quot;</span>, dev_id, new_data[idx]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化主机端数据（全1矩阵）</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">host_data</span><span class="hljs-params">(NX * NY * NZ, <span class="hljs-number">1.0</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> expected_value = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// 预期结果（所有输入为1时的平均值）</span><br><br>    <span class="hljs-comment">// 步骤1: 初始化HIP并启用设备间P2P访问</span><br>    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipInit</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id)); <span class="hljs-comment">// 绑定当前线程到指定DCU</span><br>        <br>        <span class="hljs-comment">// 启用设备间的点对点内存访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> peer=<span class="hljs-number">0</span>; peer&lt;NUM_DEVICES; ++peer) &#123;<br>            <span class="hljs-keyword">if</span> (peer != dev_id) &#123;<br>                <span class="hljs-type">int</span> canAccess = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceCanAccessPeer</span>(&amp;canAccess, dev_id, peer));<br>                <span class="hljs-keyword">if</span> (canAccess) &#123;<br>                    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceEnablePeerAccess</span>(peer, <span class="hljs-number">0</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤2: 多卡并行计算（每个OpenMP线程对应一个DCU）</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br>        <br>        <span class="hljs-comment">/* ---------- 数据划分与内存分配 ---------- */</span><br>        <span class="hljs-comment">// 将Z轴划分为4个连续区域（每个设备处理一部分）</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES<span class="hljs-number">-1</span>) ?   <span class="hljs-comment">// 全局结束层</span><br>            total_z : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span>*HALO;  <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-comment">// 设备内存分配（包含Halo区）</span><br>        <span class="hljs-type">double</span> *d_data, *d_new;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_data, NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_new, NX*NY*local_z*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br><br>        <span class="hljs-comment">/* ---------- 数据初始化 ---------- */</span><br>        <span class="hljs-comment">// 主机端缓冲区初始化（包含Halo区）</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">local_host</span><span class="hljs-params">(NX * NY * local_z, <span class="hljs-number">0.0</span>)</span></span>; <span class="hljs-comment">// 初始化为0</span><br><br>        <span class="hljs-comment">// 将host_data的相应部分拷贝到local_host（含Halo区）</span><br>        <span class="hljs-type">int</span> global_z_start = z_start - HALO; <span class="hljs-comment">// 全局起始层（含Halo）</span><br>        <span class="hljs-type">int</span> global_z_end = z_end + HALO;     <span class="hljs-comment">// 全局结束层（含Halo）</span><br><br>        <span class="hljs-comment">// 遍历每一层（含Halo区）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; local_z; ++z) &#123;<br>            <span class="hljs-type">int</span> global_z = global_z_start + z; <span class="hljs-comment">// 计算全局Z坐标</span><br>            <span class="hljs-keyword">if</span> (global_z &gt;= <span class="hljs-number">0</span> &amp;&amp; global_z &lt; NZ) &#123; <span class="hljs-comment">// 检查边界</span><br>                <span class="hljs-comment">// 拷贝当前层的数据</span><br>                std::<span class="hljs-built_in">memcpy</span>(<br>                    &amp;local_host[z * NX * NY],         <span class="hljs-comment">// local_host的目标地址</span><br>                    &amp;host_data[global_z * NX * NY],   <span class="hljs-comment">// host_data的源地址</span><br>                    NX * NY * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)          <span class="hljs-comment">// 数据大小（一层）</span><br>                );<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 0，初始化上方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; HALO; ++z) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x) &#123;<br>                        local_host[z * NX * NY + y * NX + x] = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// 默认值</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 3，初始化下方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = local_z - HALO; z &lt; local_z; ++z) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x) &#123;<br>                        local_host[z * NX * NY + y * NX + x] = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// 默认值</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将数据拷贝到设备（含Halo区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            d_data, <br>            local_host.<span class="hljs-built_in">data</span>(), <br>            NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <br>            hipMemcpyHostToDevice<br>        ));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 数据拷贝到设备完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-comment">// 定义线程块和网格大小</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">// 每个线程块4x4x4线程</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            (NX + block.x - <span class="hljs-number">1</span>) / block.x,        <span class="hljs-comment">// X方向网格数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (NY + block.y - <span class="hljs-number">1</span>) / block.y,        <span class="hljs-comment">// Y方向</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (local_z - <span class="hljs-number">2</span>*HALO + block.z <span class="hljs-number">-1</span>)/block.z <span class="hljs-comment">// Z方向（仅计算有效区域）</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><br>        <span class="hljs-comment">// 创建HIP流（用于异步操作）</span><br>        hipStream_t stream;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamCreate</span>(&amp;stream));<br><br>        <span class="hljs-comment">/* ---------- 核函数执行 ---------- */</span><br>        <span class="hljs-built_in">hipLaunchKernelGGL</span>(<br>            stencil7pt_kernel, <span class="hljs-comment">// 核函数名</span><br>            grid, block,        <span class="hljs-comment">// 网格/线程块配置</span><br>            <span class="hljs-number">0</span>, stream,         <span class="hljs-comment">// 共享内存大小和流</span><br>            d_data, d_new,     <span class="hljs-comment">// 输入输出数据</span><br>            local_z, dev_id    <span class="hljs-comment">// 附加参数</span><br>        );<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 核函数执行完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- Halo区数据交换 ---------- */</span><br>        <span class="hljs-comment">// 设备 0：向下游设备（设备 1）发送下方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span>* send_ptr = d_new + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr, dev_id,                   <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向下游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 0：从下游设备（设备 1）接收上方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span>* recv_ptr = d_new + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                <span class="hljs-comment">// 本卡接收地址</span><br>                d_new + HALO * NX * NY,          <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id + <span class="hljs-number">1</span>,                      <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-comment">// 数据大小</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 3：从上游设备（设备 2）接收上方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">double</span>* recv_ptr = d_new + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                <span class="hljs-comment">// 本卡接收地址</span><br>                d_new + HALO * NX * NY,          <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id - <span class="hljs-number">1</span>,                      <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-comment">// 数据大小</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 3：向上游设备（设备 2）发送下方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">double</span>* send_ptr = d_new + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id - <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr, dev_id,                   <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向上游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 1 和 2：双向 Halo 区交换</span><br>        <span class="hljs-keyword">if</span> (dev_id &gt; <span class="hljs-number">0</span> &amp;&amp; dev_id &lt; NUM_DEVICES - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向下游设备（设备 2）发送下方 Halo 区数据</span><br>            <span class="hljs-type">double</span>* send_ptr_down = d_new + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr_down, dev_id,              <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向下游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 向上游设备（设备 0）发送上方 Halo 区数据</span><br>            <span class="hljs-type">double</span>* send_ptr_up = d_new + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id - <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr_up, dev_id,                <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向上游设备发送上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 从上游设备（设备 0）接收上方 Halo 区数据</span><br>            <span class="hljs-type">double</span>* recv_ptr_up = d_new + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr_up, dev_id,                <span class="hljs-comment">// 本卡接收地址</span><br>                d_new + HALO * NX * NY,             <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id - <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 从下游设备（设备 2）接收下方 Halo 区数据</span><br>            <span class="hljs-type">double</span>* recv_ptr_down = d_new + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_new + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                         <span class="hljs-comment">// 目标设备 ID</span><br>                recv_ptr_down, dev_id,              <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),    <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream<br>            ));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有操作完成</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamSynchronize</span>(stream));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: Halo 区交换完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- 结果验证 ---------- */</span><br>        <span class="hljs-comment">// 将设备数据拷贝回主机</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            local_host.<span class="hljs-built_in">data</span>(), <br>            d_new,<br>            NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),<br>            hipMemcpyDeviceToHost<br>        ));<br>        <br>        <span class="hljs-comment">// 检查每个点的计算结果</span><br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = HALO; z &lt; local_z - HALO; ++z) &#123;        <span class="hljs-comment">// 遍历有效区域</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = HALO; y &lt; NY - HALO; ++y) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = HALO; x &lt; NX - HALO; ++x) &#123;<br>                    <span class="hljs-type">double</span> val = local_host[z * NX * NY + y * NX + x];<br>                    <span class="hljs-comment">// 允许1e-6的浮点误差</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(val - expected_value) &gt; <span class="hljs-number">1e-6</span>) &#123;<br>                        valid = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical <span class="hljs-comment">// 临界区保护输出</span></span><br>                        &#123;<br>                            std::cerr &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id <br>                                      &lt;&lt; <span class="hljs-string">&quot; 错误 @ (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; z <br>                                      &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; vs &quot;</span> &lt;&lt; expected_value <br>                                      &lt;&lt; std::endl;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 输出验证结果</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp critical</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> <br>                      &lt;&lt; (valid ? <span class="hljs-string">&quot;✓ 验证通过&quot;</span> : <span class="hljs-string">&quot;✗ 验证失败&quot;</span>) <br>                      &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">/* ---------- 资源释放 ---------- */</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_data));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_new));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamDestroy</span>(stream));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将原数组的值设置为不同的值，更有说服力，先halo通信然后计算，最后将计算后的数据传回进行总体验证"><a href="#将原数组的值设置为不同的值，更有说服力，先halo通信然后计算，最后将计算后的数据传回进行总体验证" class="headerlink" title="将原数组的值设置为不同的值，更有说服力，先halo通信然后计算，最后将计算后的数据传回进行总体验证"></a>将原数组的值设置为不同的值，更有说服力，先halo通信然后计算，最后将计算后的数据传回进行总体验证</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 定义网格参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 64         <span class="hljs-comment">// X维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 64         <span class="hljs-comment">// Y维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 64         <span class="hljs-comment">// Z维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALO 1        <span class="hljs-comment">// Halo区层数（7点Stencil需要1层）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_DEVICES 4 <span class="hljs-comment">// 使用的DCU卡数量</span></span><br><br><span class="hljs-comment">// HIP错误检查宏（每个HIP API调用后都应使用此宏检查）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIP_CHECK(cmd)                                                                \</span><br><span class="hljs-meta">    &#123;                                                                                 \</span><br><span class="hljs-meta">        hipError_t <span class="hljs-keyword">error</span> = cmd;                                                       \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span> != hipSuccess)                                                      \</span><br><span class="hljs-meta">        &#123;                                                                             \</span><br><span class="hljs-meta">            std::cerr &lt;&lt; <span class="hljs-string">&quot;HIP错误: &quot;</span> &lt;&lt; hipGetErrorString(<span class="hljs-keyword">error</span>)                      \</span><br><span class="hljs-meta">                      &lt;&lt; <span class="hljs-string">&quot; 文件: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot; 行号: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl; \</span><br><span class="hljs-meta">            exit(EXIT_FAILURE);                                                       \</span><br><span class="hljs-meta">        &#125;                                                                             \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 7点Stencil计算核函数</span><br><span class="hljs-comment"> * @param data    输入数据指针</span><br><span class="hljs-comment"> * @param new_data 输出数据指针</span><br><span class="hljs-comment"> * @param local_nz 当前设备处理的Z轴总层数（含Halo）</span><br><span class="hljs-comment"> * @param dev_id   设备ID（用于调试输出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">stencil7pt_kernel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> *data,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> *new_data,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> local_nz,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 计算全局线程索引（跳过Halo区）</span><br>    <span class="hljs-type">int</span> z = blockIdx.z * blockDim.z + threadIdx.z + HALO;<br>    <span class="hljs-type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y + HALO;<br>    <span class="hljs-type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x + HALO;<br><br>    <span class="hljs-comment">// 检查是否在有效计算区域内</span><br>    <span class="hljs-keyword">if</span> (x &lt; NX - HALO &amp;&amp; y &lt; NY - HALO &amp;&amp; z &lt; (local_nz - HALO))<br>    &#123;<br>        <span class="hljs-comment">// 计算一维索引（行优先存储）</span><br>        <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br><br>        <span class="hljs-comment">// 7点Stencil计算：中心点与六个相邻点相加后除以7</span><br>        new_data[idx] = (data[idx]             <span class="hljs-comment">// 中心点</span><br>                         + data[idx + <span class="hljs-number">1</span>]       <span class="hljs-comment">// x+1方向</span><br>                         + data[idx - <span class="hljs-number">1</span>]       <span class="hljs-comment">// x-1方向</span><br>                         + data[idx + NX]      <span class="hljs-comment">// y+1方向</span><br>                         + data[idx - NX]      <span class="hljs-comment">// y-1方向</span><br>                         + data[idx + NX * NY] <span class="hljs-comment">// z+1方向</span><br>                         + data[idx - NX * NY] <span class="hljs-comment">// z-1方向</span><br>                         ) /<br>                        <span class="hljs-number">7.0</span>;<br><br>        <span class="hljs-comment">// 调试输出：每个设备第一个计算点的值</span><br>        <span class="hljs-keyword">if</span> (x == HALO &amp;&amp; y == HALO &amp;&amp; z == HALO)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device %d: new_data=%.2f\n&quot;</span>, dev_id, new_data[idx]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化主机端数据（不完全为1）</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">host_data</span><span class="hljs-params">(NX * NY * NZ)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; NZ; ++z)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>            &#123;<br>                host_data[z * NX * NY + y * NX + x] = x + y + z; <span class="hljs-comment">// 值为 x + y + z</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤1: 初始化HIP并启用设备间P2P访问</span><br>    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipInit</span>(<span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id)); <span class="hljs-comment">// 绑定当前线程到指定DCU</span><br><br>        <span class="hljs-comment">// 启用设备间的点对点内存访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> peer = <span class="hljs-number">0</span>; peer &lt; NUM_DEVICES; ++peer)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (peer != dev_id)<br>            &#123;<br>                <span class="hljs-type">int</span> canAccess = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceCanAccessPeer</span>(&amp;canAccess, dev_id, peer));<br>                <span class="hljs-keyword">if</span> (canAccess)<br>                &#123;<br>                    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipDeviceEnablePeerAccess</span>(peer, <span class="hljs-number">0</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 步骤2: 多卡并行计算（每个OpenMP线程对应一个DCU）</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(NUM_DEVICES)</span><br>    &#123;<br>        <span class="hljs-type">int</span> dev_id = <span class="hljs-built_in">omp_get_thread_num</span>();<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br><br>        <span class="hljs-comment">/* ---------- 数据划分与内存分配 ---------- */</span><br>        <span class="hljs-comment">// 将Z轴划分为4个连续区域（每个设备处理一部分）</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) ? <span class="hljs-comment">// 全局结束层</span><br>                        total_z<br>                                                : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span> * HALO; <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-comment">// 设备内存分配（包含Halo区）</span><br>        <span class="hljs-type">double</span> *d_data, *d_new;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_data, NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_new, NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br><br>        <span class="hljs-comment">/* ---------- 数据初始化 ---------- */</span><br>        <span class="hljs-comment">// 主机端缓冲区初始化（包含Halo区）</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">local_host</span><span class="hljs-params">(NX * NY * local_z, <span class="hljs-number">0.0</span>)</span></span>; <span class="hljs-comment">// 初始化为0</span><br><br>        <span class="hljs-comment">// 将host_data的相应部分拷贝到local_host（含Halo区）</span><br>        <span class="hljs-type">int</span> global_z_start = z_start - HALO; <span class="hljs-comment">// 全局起始层（含Halo）</span><br>        <span class="hljs-type">int</span> global_z_end = z_end + HALO;     <span class="hljs-comment">// 全局结束层（含Halo）</span><br><br>        <span class="hljs-comment">// 遍历每一层（含Halo区）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; local_z; ++z)<br>        &#123;<br>            <span class="hljs-type">int</span> global_z = global_z_start + z; <span class="hljs-comment">// 计算全局Z坐标</span><br>            <span class="hljs-keyword">if</span> (global_z &gt;= <span class="hljs-number">0</span> &amp;&amp; global_z &lt; NZ)<br>            &#123; <span class="hljs-comment">// 检查边界</span><br>                <span class="hljs-comment">// 拷贝当前层的数据</span><br>                std::<span class="hljs-built_in">memcpy</span>(<br>                    &amp;local_host[z * NX * NY],       <span class="hljs-comment">// local_host的目标地址</span><br>                    &amp;host_data[global_z * NX * NY], <span class="hljs-comment">// host_data的源地址</span><br>                    NX * NY * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)        <span class="hljs-comment">// 数据大小（一层）</span><br>                );<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 0，初始化上方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; HALO; ++z)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                    &#123;<br>                        local_host[z * NX * NY + y * NX + x] = x + y + (global_z_start + z); <span class="hljs-comment">// 默认值为 x + y + z</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 3，初始化下方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = local_z - HALO; z &lt; local_z; ++z)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                    &#123;<br>                        local_host[z * NX * NY + y * NX + x] = x + y + (global_z_start + z); <span class="hljs-comment">// 默认值为 x + y + z</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将数据拷贝到设备（含Halo区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            d_data,<br>            local_host.<span class="hljs-built_in">data</span>(),<br>            NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),<br>            hipMemcpyHostToDevice));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 数据拷贝到设备完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-comment">// 定义线程块和网格大小</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">// 每个线程块4x4x4线程</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            (NX + block.x - <span class="hljs-number">1</span>) / block.x,                <span class="hljs-comment">// X方向网格数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (NY + block.y - <span class="hljs-number">1</span>) / block.y,                <span class="hljs-comment">// Y方向</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (local_z - <span class="hljs-number">2</span> * HALO + block.z - <span class="hljs-number">1</span>) / block.z <span class="hljs-comment">// Z方向（仅计算有效区域）</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><br>        <span class="hljs-comment">// 创建HIP流（用于异步操作）</span><br>        hipStream_t stream;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamCreate</span>(&amp;stream));<br><br>        <span class="hljs-comment">/* ---------- Halo区数据交换 ---------- */</span><br>        <span class="hljs-comment">// 设备 0：向下游设备（设备 1）发送下方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *send_ptr = d_data + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_data + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                          <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr, dev_id,                    <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),     <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向下游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 0：从下游设备（设备 1）接收上方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *recv_ptr = d_data + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                <span class="hljs-comment">// 本卡接收地址</span><br>                d_data + HALO * NX * NY,         <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id + <span class="hljs-number">1</span>,                      <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-comment">// 数据大小</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 3：从上游设备（设备 2）接收上方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *recv_ptr = d_data + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                <span class="hljs-comment">// 本卡接收地址</span><br>                d_data + HALO * NX * NY,         <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id - <span class="hljs-number">1</span>,                      <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-comment">// 数据大小</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 3：向上游设备（设备 2）发送下方 Halo 区数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *send_ptr = d_data + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_data + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id - <span class="hljs-number">1</span>,                          <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr, dev_id,                    <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),     <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向上游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 1 和 2：双向 Halo 区交换</span><br>        <span class="hljs-keyword">if</span> (dev_id &gt; <span class="hljs-number">0</span> &amp;&amp; dev_id &lt; NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 向下游设备（设备 2）发送下方 Halo 区数据</span><br>            <span class="hljs-type">double</span> *send_ptr_down = d_data + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_data + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                          <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr_down, dev_id,               <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),     <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向下游设备发送下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 向上游设备（设备 0）发送上方 Halo 区数据</span><br>            <span class="hljs-type">double</span> *send_ptr_up = d_data + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_data + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id - <span class="hljs-number">1</span>,                          <span class="hljs-comment">// 目标设备 ID</span><br>                send_ptr_up, dev_id,                 <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),     <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 向上游设备发送上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 从上游设备（设备 0）接收上方 Halo 区数据</span><br>            <span class="hljs-type">double</span> *recv_ptr_up = d_data + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY; <span class="hljs-comment">// 本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr_up, dev_id,             <span class="hljs-comment">// 本卡接收地址</span><br>                d_data + HALO * NX * NY,         <span class="hljs-comment">// 源卡的有效区顶部</span><br>                dev_id - <span class="hljs-number">1</span>,                      <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-comment">// 数据大小</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收上方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 从下游设备（设备 2）接收下方 Halo 区数据</span><br>            <span class="hljs-type">double</span> *recv_ptr_down = d_data + HALO * NX * NY; <span class="hljs-comment">// 本卡有效区底部</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                d_data + (local_z - HALO) * NX * NY, <span class="hljs-comment">// 目标卡的上方 Halo 区</span><br>                dev_id + <span class="hljs-number">1</span>,                          <span class="hljs-comment">// 目标设备 ID</span><br>                recv_ptr_down, dev_id,               <span class="hljs-comment">// 源数据指针和设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),     <span class="hljs-comment">// 数据大小（1 层 Halo）</span><br>                stream));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收下方 Halo 数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有 Halo 区数据交换完成</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamSynchronize</span>(stream));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: Halo 区交换完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- 核函数执行 ---------- */</span><br>        <span class="hljs-built_in">hipLaunchKernelGGL</span>(<br>            stencil7pt_kernel, <span class="hljs-comment">// 核函数名</span><br>            grid, block,       <span class="hljs-comment">// 网格/线程块配置</span><br>            <span class="hljs-number">0</span>, stream,         <span class="hljs-comment">// 共享内存大小和流</span><br>            d_data, d_new,     <span class="hljs-comment">// 输入输出数据</span><br>            local_z, dev_id    <span class="hljs-comment">// 附加参数</span><br>        );<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 核函数执行完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">/* ---------- 将设备数据拷贝回主机 ---------- */</span><br>        <span class="hljs-comment">// 将local_host的结果传回host_data的对应部分</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = HALO; z &lt; local_z - HALO; ++z)<br>        &#123;<br>            <span class="hljs-type">int</span> global_z = z_start + z - HALO; <span class="hljs-comment">// 计算全局Z坐标</span><br>            std::<span class="hljs-built_in">memcpy</span>(<br>                &amp;host_data[global_z * NX * NY], <span class="hljs-comment">// host_data的目标地址</span><br>                &amp;local_host[z * NX * NY],       <span class="hljs-comment">// local_host的源地址</span><br>                NX * NY * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)        <span class="hljs-comment">// 数据大小（一层）</span><br>            );<br>        &#125;<br><br>        <span class="hljs-comment">/* ---------- 资源释放 ---------- */</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_data));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_new));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamDestroy</span>(stream));<br>    &#125;<br><br>    <span class="hljs-comment">/* ---------- 结果验证 ---------- */</span><br>    <span class="hljs-comment">// 在所有设备计算完成后，统一验证host_data的结果</span><br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; NZ; ++z)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>            &#123;<br>                <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br>                <span class="hljs-type">double</span> val = host_data[idx];<br><br>                <span class="hljs-comment">// 计算预期值</span><br>                <span class="hljs-type">double</span> expected_value = (x + y + z)        <span class="hljs-comment">// 中心点</span><br>                                        + (x + <span class="hljs-number">1</span> + y + z)  <span class="hljs-comment">// x+1方向</span><br>                                        + (x - <span class="hljs-number">1</span> + y + z)  <span class="hljs-comment">// x-1方向</span><br>                                        + (x + y + <span class="hljs-number">1</span> + z)  <span class="hljs-comment">// y+1方向</span><br>                                        + (x + y - <span class="hljs-number">1</span> + z)  <span class="hljs-comment">// y-1方向</span><br>                                        + (x + y + z + <span class="hljs-number">1</span>)  <span class="hljs-comment">// z+1方向</span><br>                                        + (x + y + z - <span class="hljs-number">1</span>); <span class="hljs-comment">// z-1方向</span><br>                expected_value /= <span class="hljs-number">7.0</span>;                     <span class="hljs-comment">// 除以7</span><br><br>                <span class="hljs-comment">// 允许1e-6的浮点误差</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(val - expected_value) &gt; <span class="hljs-number">1e-6</span>)<br>                &#123;<br>                    valid = <span class="hljs-literal">false</span>;<br>                    std::cerr &lt;&lt; <span class="hljs-string">&quot;错误 @ (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; z<br>                              &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; vs &quot;</span> &lt;&lt; expected_value<br>                              &lt;&lt; std::endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!valid)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!valid)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出验证结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;验证结果: &quot;</span><br>              &lt;&lt; (valid ? <span class="hljs-string">&quot;✓ 验证通过&quot;</span> : <span class="hljs-string">&quot;✗ 验证失败&quot;</span>)<br>              &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="成功demo"><a href="#成功demo" class="headerlink" title="成功demo"></a>成功demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 定义网格参数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 64         <span class="hljs-comment">// X维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 64         <span class="hljs-comment">// Y维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 64         <span class="hljs-comment">// Z维度网格点数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALO 1        <span class="hljs-comment">// Halo区层数（7点Stencil需要1层）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_DEVICES 4 <span class="hljs-comment">// 使用的DCU卡数量</span></span><br><br><span class="hljs-comment">// HIP错误检查宏（每个HIP API调用后都应使用此宏检查）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIP_CHECK(cmd)                                                                \</span><br><span class="hljs-meta">    &#123;                                                                                 \</span><br><span class="hljs-meta">        hipError_t <span class="hljs-keyword">error</span> = cmd;                                                       \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span> != hipSuccess)                                                      \</span><br><span class="hljs-meta">        &#123;                                                                             \</span><br><span class="hljs-meta">            std::cerr &lt;&lt; <span class="hljs-string">&quot;HIP错误: &quot;</span> &lt;&lt; hipGetErrorString(<span class="hljs-keyword">error</span>)                      \</span><br><span class="hljs-meta">                      &lt;&lt; <span class="hljs-string">&quot; 文件: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot; 行号: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; std::endl; \</span><br><span class="hljs-meta">            exit(EXIT_FAILURE);                                                       \</span><br><span class="hljs-meta">        &#125;                                                                             \</span><br><span class="hljs-meta">    &#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 7点Stencil计算核函数</span><br><span class="hljs-comment"> * @param data    输入数据指针</span><br><span class="hljs-comment"> * @param new_data 输出数据指针</span><br><span class="hljs-comment"> * @param local_nz 当前设备处理的Z轴总层数（含Halo）</span><br><span class="hljs-comment"> * @param dev_id   设备ID（用于调试输出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">stencil7pt_kernel</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> *data,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span> *new_data,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> local_nz,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 计算全局线程索引（跳过Halo区）</span><br>    <span class="hljs-type">int</span> z = blockIdx.z * blockDim.z + threadIdx.z + HALO;<br>    <span class="hljs-type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y + HALO;<br>    <span class="hljs-type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x + HALO;<br><br>    <span class="hljs-comment">// 检查是否在有效计算区域内</span><br>    <span class="hljs-keyword">if</span> (x &lt; NX - HALO &amp;&amp; y &lt; NY - HALO &amp;&amp; z &lt; (local_nz - HALO))<br>    &#123;<br>        <span class="hljs-comment">// 计算一维索引（行优先存储）</span><br>        <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br><br>        <span class="hljs-comment">// 7点Stencil计算：中心点与六个相邻点相加后除以7</span><br>        new_data[idx] = (data[idx]             <span class="hljs-comment">// 中心点</span><br>                         + data[idx + <span class="hljs-number">1</span>]       <span class="hljs-comment">// x+1方向</span><br>                         + data[idx - <span class="hljs-number">1</span>]       <span class="hljs-comment">// x-1方向</span><br>                         + data[idx + NX]      <span class="hljs-comment">// y+1方向</span><br>                         + data[idx - NX]      <span class="hljs-comment">// y-1方向</span><br>                         + data[idx + NX * NY] <span class="hljs-comment">// z+1方向</span><br>                         + data[idx - NX * NY] <span class="hljs-comment">// z-1方向</span><br>                         ) /<br>                        <span class="hljs-number">7.0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始化主机端数据</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">host_data</span><span class="hljs-params">(NX * NY * NZ)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; NZ; ++z)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>            &#123;<br>                host_data[z * NX * NY + y * NX + x] = x * y * z; <span class="hljs-comment">// 值为 x + y + z</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤1: 初始化HIP并启用设备间P2P访问</span><br>    <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipInit</span>(<span class="hljs-number">0</span>));<br><span class="hljs-comment">/*    for (int dev_id = 0; dev_id &lt; NUM_DEVICES; ++dev_id)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        HIP_CHECK(hipSetDevice(dev_id)); // 绑定当前线程到指定DCU</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        // 启用设备间的点对点内存访问</span><br><span class="hljs-comment">        for (int peer = 0; peer &lt; NUM_DEVICES; ++peer)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if (peer != dev_id)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                int canAccess = 0;</span><br><span class="hljs-comment">                HIP_CHECK(hipDeviceCanAccessPeer(&amp;canAccess, dev_id, peer));</span><br><span class="hljs-comment">                if (canAccess)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    HIP_CHECK(hipDeviceEnablePeerAccess(peer, 0));</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-comment">// 步骤2: 为每个设备分配独立的内存</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span> *&gt; <span class="hljs-title">d_data_list</span><span class="hljs-params">(NUM_DEVICES)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span> *&gt; <span class="hljs-title">d_new_list</span><span class="hljs-params">(NUM_DEVICES)</span></span>;<br>    <span class="hljs-function">std::vector&lt;hipStream_t&gt; <span class="hljs-title">streams</span><span class="hljs-params">(NUM_DEVICES)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dev_id = <span class="hljs-number">0</span>; dev_id &lt; NUM_DEVICES; ++dev_id)<br>    &#123;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br><br>        <span class="hljs-comment">/* ---------- 数据划分与内存分配 ---------- */</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) ? <span class="hljs-comment">// 全局结束层</span><br>                        total_z<br>                                                : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span> * HALO; <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-comment">// 设备内存分配（包含Halo区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_data_list[dev_id], NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMalloc</span>(&amp;d_new_list[dev_id], NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)));<br><br>        <span class="hljs-comment">/* ---------- 数据初始化 ---------- */</span><br>        <span class="hljs-comment">// 主机端缓冲区初始化（包含Halo区）</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">local_host</span><span class="hljs-params">(NX * NY * local_z, <span class="hljs-number">0.0</span>)</span></span>; <span class="hljs-comment">// 初始化为0</span><br><br>        <span class="hljs-comment">// 将host_data的相应部分拷贝到local_host（含Halo区）</span><br>        <span class="hljs-type">int</span> global_z_start = z_start - HALO; <span class="hljs-comment">// 全局起始层（含Halo）</span><br>        <span class="hljs-type">int</span> global_z_end = z_end + HALO;     <span class="hljs-comment">// 全局结束层（含Halo）</span><br><br>        <span class="hljs-comment">// 遍历每一层（含Halo区）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; local_z; ++z)<br>        &#123;<br>            <span class="hljs-type">int</span> global_z = global_z_start + z; <span class="hljs-comment">// 计算全局Z坐标</span><br>            <span class="hljs-keyword">if</span> (global_z &gt;= <span class="hljs-number">0</span> &amp;&amp; global_z &lt; NZ)<br>            &#123; <span class="hljs-comment">// 检查边界</span><br>                <span class="hljs-comment">// 计算 local_host 的目标地址</span><br>                <span class="hljs-type">int</span> local_z_idx = z; <span class="hljs-comment">// local_host 的当前层索引</span><br>                <span class="hljs-keyword">if</span> (z &lt; HALO)<br>                &#123;<br>                    <span class="hljs-comment">// 上方 Halo 区：初始化为默认值</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                        &#123;<br>                            local_host[local_z_idx * NX * NY + y * NX + x] = <span class="hljs-number">0</span>;<span class="hljs-comment">// x + y + (global_z_start + z); // 默认值为 x + y + z</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z &gt;= local_z - HALO)<br>                &#123;<br>                    <span class="hljs-comment">// 下方 Halo 区：初始化为默认值</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                        &#123;<br>                            local_host[local_z_idx * NX * NY + y * NX + x] = <span class="hljs-number">0</span>;<span class="hljs-comment">// x + y + (global_z_start + z); // 默认值为 x + y + z</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 有效区域：将数据拷贝到 local_host 的非 Halo 区域</span><br>                    std::<span class="hljs-built_in">memcpy</span>(<br>                        &amp;local_host[local_z_idx * NX * NY], <span class="hljs-comment">// local_host 的目标地址</span><br>                        &amp;host_data[global_z * NX * NY],     <span class="hljs-comment">// host_data 的源地址</span><br>                        NX * NY * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)            <span class="hljs-comment">// 数据大小（一层）</span><br>                    );<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 0，初始化上方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; HALO; ++z)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                    &#123;<br>                        local_host[z * NX * NY + y * NX + x] = <span class="hljs-number">0</span>; <span class="hljs-comment">// x + y + (global_z_start + z); // 默认值为 x + y + z</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 对于 Device 3，初始化下方 Halo 区为默认值</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = local_z - HALO; z &lt; local_z; ++z)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; NY; ++y)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; NX; ++x)<br>                    &#123;<br>                        local_host[z * NX * NY + y * NX + x] = <span class="hljs-number">0</span>; <span class="hljs-comment">// x + y + (global_z_start + z); // 默认值为 x + y + z</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将数据拷贝到设备（含Halo区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            d_data_list[dev_id],<br>            local_host.<span class="hljs-built_in">data</span>(),<br>            NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),<br>            hipMemcpyHostToDevice));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 数据拷贝到设备完成&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 创建流</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamCreate</span>(&amp;streams[dev_id]));<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤3: 多卡并行计算</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dev_id = <span class="hljs-number">0</span>; dev_id &lt; NUM_DEVICES; ++dev_id)<br>    &#123;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) ? <span class="hljs-comment">// 全局结束层</span><br>                        total_z<br>                                                : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span> * HALO; <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">// 每个线程块4x4x4线程</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            (NX + block.x - <span class="hljs-number">1</span>) / block.x,                <span class="hljs-comment">// X方向网格数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (NY + block.y - <span class="hljs-number">1</span>) / block.y,                <span class="hljs-comment">// Y方向</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (local_z - <span class="hljs-number">2</span> * HALO + block.z - <span class="hljs-number">1</span>) / block.z <span class="hljs-comment">// Z方向（仅计算有效区域）</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><br><br>        <span class="hljs-comment">/* ---------- Halo区数据交换 ---------- */</span><br>        <span class="hljs-comment">// 设备 0：从下游设备（设备 1）接收有效区域顶部数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *recv_ptr = d_data_list[dev_id] + (local_z - HALO) * NX * NY; <span class="hljs-comment">// 目的 Halo 区：设备 0 的下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                         <span class="hljs-comment">// 本卡接收地址</span><br>                d_data_list[dev_id + <span class="hljs-number">1</span>] + HALO * NX * NY, <span class="hljs-comment">// 源数据：设备 1 的有效区域顶部</span><br>                dev_id + <span class="hljs-number">1</span>,                               <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),          <span class="hljs-comment">// 数据大小</span><br>                streams[dev_id]));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收有效区域顶部数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 3：从上游设备（设备 2）接收有效区域底部数据</span><br>        <span class="hljs-keyword">if</span> (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> *recv_ptr = d_data_list[dev_id]; <span class="hljs-comment">// 目的 Halo 区：设备 3 的上方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr, dev_id,                                         <span class="hljs-comment">// 本卡接收地址</span><br>                d_data_list[dev_id - <span class="hljs-number">1</span>] + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY, <span class="hljs-comment">// 源数据：设备 2 的有效区域底部</span><br>                dev_id - <span class="hljs-number">1</span>,                                               <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),                          <span class="hljs-comment">// 数据大小</span><br>                streams[dev_id]));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收有效区域底部数据&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-comment">// 设备 1 和 2：双向 Halo 区交换</span><br>        <span class="hljs-keyword">if</span> (dev_id &gt; <span class="hljs-number">0</span> &amp;&amp; dev_id &lt; NUM_DEVICES - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 从上游设备（设备 0）接收有效区域底部数据</span><br>            <span class="hljs-type">double</span> *recv_ptr_up = d_data_list[dev_id]; <span class="hljs-comment">// 目的 Halo 区：本卡上方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr_up, dev_id,                                      <span class="hljs-comment">// 本卡接收地址</span><br>                d_data_list[dev_id - <span class="hljs-number">1</span>] + (local_z - <span class="hljs-number">2</span> * HALO) * NX * NY, <span class="hljs-comment">// 源数据：上游设备（设备 0）的有效区域底部</span><br>                dev_id - <span class="hljs-number">1</span>,                                               <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),                          <span class="hljs-comment">// 数据大小</span><br>                streams[dev_id]));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从上游设备接收有效区域底部数据&quot;</span> &lt;&lt; std::endl;<br><br>            <span class="hljs-comment">// 从下游设备（设备 2）接收有效区域顶部数据</span><br>            <span class="hljs-type">double</span> *recv_ptr_down = d_data_list[dev_id] + (local_z - HALO) * NX * NY; <span class="hljs-comment">// 目的 Halo 区：本卡下方 Halo 区</span><br>            <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpyPeerAsync</span>(<br>                recv_ptr_down, dev_id,                    <span class="hljs-comment">// 本卡接收地址</span><br>                d_data_list[dev_id + <span class="hljs-number">1</span>] + HALO * NX * NY, <span class="hljs-comment">// 源数据：下游设备（设备 2）的有效区域顶部</span><br>                dev_id + <span class="hljs-number">1</span>,                               <span class="hljs-comment">// 源设备 ID</span><br>                NX * NY * HALO * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),          <span class="hljs-comment">// 数据大小</span><br>                streams[dev_id]));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 从下游设备接收有效区域顶部数据&quot;</span> &lt;&lt; std::endl;<br><br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 等待所有设备的 Halo 区交换完成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dev_id = <span class="hljs-number">0</span>; dev_id &lt; NUM_DEVICES; ++dev_id)<br>    &#123;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamSynchronize</span>(streams[dev_id]));<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: Halo 区交换完成&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 所有设备的 Halo 区交换完成后，执行核函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dev_id = <span class="hljs-number">0</span>; dev_id &lt; NUM_DEVICES; ++dev_id)<br>    &#123;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) ? <span class="hljs-comment">// 全局结束层</span><br>                        total_z<br>                                                : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span> * HALO; <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">// 每个线程块4x4x4线程</span><br>        <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            (NX + block.x - <span class="hljs-number">1</span>) / block.x,                <span class="hljs-comment">// X方向网格数</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (NY + block.y - <span class="hljs-number">1</span>) / block.y,                <span class="hljs-comment">// Y方向</span></span></span><br><span class="hljs-params"><span class="hljs-function">            (local_z - <span class="hljs-number">2</span> * HALO + block.z - <span class="hljs-number">1</span>) / block.z <span class="hljs-comment">// Z方向（仅计算有效区域）</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><br>        <span class="hljs-comment">/* ---------- 核函数执行 ---------- */</span><br>        <span class="hljs-built_in">hipLaunchKernelGGL</span>(<br>            stencil7pt_kernel,                       <span class="hljs-comment">// 核函数名</span><br>            grid, block,                             <span class="hljs-comment">// 网格/线程块配置</span><br>            <span class="hljs-number">0</span>, streams[dev_id],                      <span class="hljs-comment">// 共享内存大小和流</span><br>            d_data_list[dev_id], d_new_list[dev_id], <span class="hljs-comment">// 输入输出数据</span><br>            local_z, dev_id                          <span class="hljs-comment">// 附加参数</span><br>        );<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Device &quot;</span> &lt;&lt; dev_id &lt;&lt; <span class="hljs-string">&quot;: 核函数执行完成&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 步骤4: 将设备数据拷贝回主机并验证</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dev_id = <span class="hljs-number">0</span>; dev_id &lt; NUM_DEVICES; ++dev_id)<br>    &#123;<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipSetDevice</span>(dev_id));<br><br>        <span class="hljs-comment">/* ---------- 计算任务配置 ---------- */</span><br>        <span class="hljs-type">int</span> total_z = NZ;                         <span class="hljs-comment">// 总层数</span><br>        <span class="hljs-type">int</span> base_z = total_z / NUM_DEVICES;       <span class="hljs-comment">// 每卡基础层数</span><br>        <span class="hljs-type">int</span> z_start = dev_id * base_z;            <span class="hljs-comment">// 全局起始层（不含Halo）</span><br>        <span class="hljs-type">int</span> z_end = (dev_id == NUM_DEVICES - <span class="hljs-number">1</span>) ? <span class="hljs-comment">// 全局结束层</span><br>                        total_z<br>                                                : z_start + base_z;<br>        <span class="hljs-type">int</span> local_z = z_end - z_start + <span class="hljs-number">2</span> * HALO; <span class="hljs-comment">// 当前卡总层数（含Halo）</span><br><br>        <span class="hljs-comment">// 主机端缓冲区初始化（包含Halo区）</span><br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">local_host</span><span class="hljs-params">(NX * NY * local_z, <span class="hljs-number">0.0</span>)</span></span>; <span class="hljs-comment">// 初始化为0</span><br><br>        <span class="hljs-comment">// 将 d_new 的数据拷贝回 local_host（含 Halo 区）</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipMemcpy</span>(<br>            local_host.<span class="hljs-built_in">data</span>(),<br>            d_new_list[dev_id], <span class="hljs-comment">// 使用 d_new 而不是 d_data</span><br>            NX * NY * local_z * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>),<br>            hipMemcpyDeviceToHost));<br><br>        <span class="hljs-comment">// 将 local_host 的有效区域数据更新到 host_data 的对应部分</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = HALO; z &lt; local_z - HALO; ++z)<br>        &#123;<br>            <span class="hljs-type">int</span> global_z = z_start + z - HALO; <span class="hljs-comment">// 计算全局 Z 坐标</span><br>            std::<span class="hljs-built_in">memcpy</span>(<br>                &amp;host_data[global_z * NX * NY], <span class="hljs-comment">// host_data 的目标地址</span><br>                &amp;local_host[z * NX * NY],       <span class="hljs-comment">// local_host 的源地址（有效区域）</span><br>                NX * NY * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)        <span class="hljs-comment">// 数据大小（一层）</span><br>            );<br>        &#125;<br><br>        <span class="hljs-comment">/* ---------- 资源释放 ---------- */</span><br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_data_list[dev_id]));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipFree</span>(d_new_list[dev_id]));<br>        <span class="hljs-built_in">HIP_CHECK</span>(<span class="hljs-built_in">hipStreamDestroy</span>(streams[dev_id]));<br>    &#125;<br><br>    <span class="hljs-comment">/* ---------- 结果验证 ---------- */</span><br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">1</span>; z &lt; NZ - <span class="hljs-number">1</span>; ++z)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt; NY - <span class="hljs-number">1</span>; ++y)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt; NX - <span class="hljs-number">1</span>; ++x)<br>            &#123;<br>                <span class="hljs-type">int</span> idx = z * NX * NY + y * NX + x;<br>                <span class="hljs-type">double</span> val = host_data[idx];<br><br>                <span class="hljs-comment">// 计算预期值</span><br>                <span class="hljs-type">double</span> expected_value = (x * y * z)          <span class="hljs-comment">// 中心点</span><br>                                        + ((x + <span class="hljs-number">1</span>) * y * z)  <span class="hljs-comment">// x+1方向</span><br>                                        + ((x - <span class="hljs-number">1</span>) * y * z)  <span class="hljs-comment">// x-1方向</span><br>                                        + (x * (y + <span class="hljs-number">1</span>) * z)  <span class="hljs-comment">// y+1方向</span><br>                                        + (x * (y - <span class="hljs-number">1</span>) * z)  <span class="hljs-comment">// y-1方向</span><br>                                        + (x * y * (z + <span class="hljs-number">1</span>))  <span class="hljs-comment">// z+1方向</span><br>                                        + (x * y * (z - <span class="hljs-number">1</span>)); <span class="hljs-comment">// z-1方向</span><br>                expected_value /= <span class="hljs-number">7.0</span>;                       <span class="hljs-comment">// 除以7</span><br><br>                <span class="hljs-comment">// 允许1e-6的浮点误差</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(val - expected_value) &gt; <span class="hljs-number">1e-6</span>)<br>                &#123;<br>                    valid = <span class="hljs-literal">false</span>;<br>                    std::cerr &lt;&lt; <span class="hljs-string">&quot;错误 @ (&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; z<br>                              &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; vs &quot;</span> &lt;&lt; expected_value<br>                              &lt;&lt; std::endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!valid)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!valid)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出验证结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;验证结果: &quot;</span><br>              &lt;&lt; (valid ? <span class="hljs-string">&quot;✓ 验证通过&quot;</span> : <span class="hljs-string">&quot;✗ 验证失败&quot;</span>)<br>              &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>past and future</title>
    <link href="/2025/02/22/past%20and%20future/"/>
    <url>/2025/02/22/past%20and%20future/</url>
    
    <content type="html"><![CDATA[<h2 id="past"><a href="#past" class="headerlink" title="past"></a>past</h2><h3 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h3><p>从2024年四月接触项目，到现在也快一年了，从最基础的linux使用命令，再到各种性能分析工具，解决了很多bug，有了明显的加速效果，并在此基础上完成了小论文初稿。接下来在此基础上进一步优化。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>java mysql html css javascipt vue maven &gt;… </p><h2 id="future"><a href="#future" class="headerlink" title="future"></a>future</h2><p>合并访存，shared memory ,stencil 优化 ,opmpmp多线程，mpi多进程</p><p>先完成openmp多线程运行，将计算任务分配到多张卡上计算。</p><h2 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h2><p>坚持健身，练腿。</p><p>尽快完成科研项目，达到毕业要求。</p><p>完善自己的技术栈。</p><p>每天都刷算法题。</p><p>做项目填充简历。</p><p>学习大模型、异构计算相关知识，为未来的职业方向多开辟一条路。</p><p>时机成熟去猪八戒网练手</p><p>You are the best ,move now!</p><h4 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h4><p>科研：完成openmp，合并访存，shared memory 部分，投出小论文。</p><p>技术栈：学完框架后，做一个项目，巩固基础，做实践</p><p>算法题：每天2道letcode</p><p>抽空学习大模型的知识</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小论文</title>
    <link href="/2024/12/16/%E8%AE%BA%E6%96%87/"/>
    <url>/2024/12/16/%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="项目背景介绍和工作重点"><a href="#项目背景介绍和工作重点" class="headerlink" title="项目背景介绍和工作重点"></a>项目背景介绍和工作重点</h2><p><strong>界面湍流模拟仿真软件（Cut-Cell）</strong></p><p>可压缩多相流模拟仿真软件</p><p>软件功能：模拟三维液滴的变形、破碎</p><p><strong>Fortran代码，目前是OpenMP版本，尚未有GPU&#x2F;DCU工作</strong> </p><p><strong>功能简述：</strong>基于笛卡尔背景网格，使用三维切割网格重构-组装生成非结构界面网格，在 </p><p>ALE框架下采用有限体积法离散和求解水&#x2F;气两相欧拉方程</p><p><strong>核心算法：</strong> </p><p>•守恒性尖锐界面方法，切割网格技术， </p><p>中科大的工作将284种一般切割模态 </p><p>减少到12种基本切割模态</p><p><strong>算法分析</strong> </p><p>• 切割网格技术涉及笛卡尔网格&#x2F;非结构网格混合，算术强度低、分支判断多，无法发挥 </p><p>GPU&#x2F;DCU计算性能 </p><p>• 二阶Runge-Kutta法推进水&#x2F;气两相欧拉方程求解，占计算时间≈**50%**，是性能热点 </p><p>• <strong>Cut-Cell优化的工作重点是：欧拉方程求解的异构移植和性能优化、以及CPU和DCU协同计算</strong> </p><hr><h2 id="已做的工作"><a href="#已做的工作" class="headerlink" title="已做的工作"></a>已做的工作</h2><p>1.使用vtune,gprof等软件对程序整体热点进行分析。对算法特征进行分析。</p><p>1.两相流欧拉方程求解部分的代码移植 fortran&gt;c ，采用混编的方式</p><p>2.欧拉方程求解的异构移植,c&gt;hipc，采用CPU和DCU协同计算，采用的并行方法…</p><p>3.设置为锁页内存，减少cpu，dcu之间的传输时间</p><p>4.通过算法重排，实现cpu，dcu之间的数据传输和cpu上的函数计算时间掩盖。使用异步传输函数hipMemcpyAsync.</p><p>5.将all_prim_2_con和all_con_2_prim两段代码（原始变量con和守恒变量的相互转换）也放在移植到dcu上面。</p><p>6.正确性验证</p><p>7.后续工作。。。</p><h2 id="论文写作重点"><a href="#论文写作重点" class="headerlink" title="论文写作重点"></a>论文写作重点</h2><p>1 引言：多相流研究背景，现状，瓶颈，提出本文异构移植计算思想<br>2 软件分析：算法框架（突出介绍stencil 和 RK 的并行优势），异构移植难点（算术强度低、分支判断多，数据传输开销大）<br>3 优化方法：测试找到程序热点模块，代码移植<br>异构计算设计（核函数设计，数据并行化与任务分配）<br>数据传输优化（锁页内存，异步传输）<br>分块（调整线程块的大小）<br>4 实验：实验环境设置，正确性验证，优化前后运行时间对比和加速比（移植部分，整体）<br>测试不同的网格优化前后时间对比。</p><p>把软件改成对问题的研究，看看论文，加上核心算法的流程，公式，必要加上图</p><p>算法流程图</p><p><img src="/../images/1734850563058.png" alt="1734850563058"></p><p><img src="/../images/1734852369209.png" alt="1734852369209"></p><h2 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a><strong>论文结构</strong></h2><p><strong>界面湍流模拟仿真软件的异构移植与性能优化</strong></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><p>概述研究背景、问题、优化方法及主要结果：</p><ul><li>背景：界面湍流模拟的重要性。</li><li>问题：传统算法在多相流计算中的性能瓶颈。</li><li>方法：提出CPU-DCU协同计算策略，使用锁页内存及异步传输优化。</li><li>结果：优化后性能提升显著，正确性验证通过。</li></ul><hr><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h3><p>1.1 <strong>研究背景</strong></p><ul><li>多相流动模拟在工程与自然科学中的广泛应用。</li><li>当前算法在三维切割网格技术上的性能挑战。</li></ul><p>1.2 <strong>研究现状</strong></p><ul><li>可压缩多相流模拟领域的研究进展。</li><li>切割网格技术及守恒性尖锐界面方法的适配性问题。</li></ul><p>1.3 <strong>本文贡献</strong></p><ul><li>提出Cut-Cell代码的异构优化方案。</li><li>使用HIP编程实现CPU和DCU协同计算。</li></ul><hr><h3 id="2-Cut-Cell软件分析"><a href="#2-Cut-Cell软件分析" class="headerlink" title="2. Cut-Cell软件分析"></a><strong>2. Cut-Cell软件分析</strong></h3><p>2.1 <strong>算法框架</strong></p><ul><li>基于笛卡尔背景网格的网格切割与重构技术。</li><li>有限体积法在ALE框架下的离散和求解。</li></ul><p>2.2 <strong>热点模块</strong></p><ul><li>欧拉方程求解中的性能瓶颈。</li><li>守恒变量与原始变量转换模块。</li></ul><p>2.3 <strong>异构移植难点</strong></p><ul><li>算术强度低、分支判断多对GPU性能的不利影响。</li><li>数据传输开销大导致的效率瓶颈。</li></ul><hr><h3 id="3-优化方法"><a href="#3-优化方法" class="headerlink" title="3. 优化方法"></a><strong>3. 优化方法</strong></h3><p>3.1 <strong>代码移植</strong></p><ul><li>Fortran到C的移植方案。</li><li>混合编程模式及接口设计。</li></ul><p>3.2 <strong>异构计算设计</strong></p><ul><li>基于HIP的核函数设计。</li><li>数据并行化与任务分配策略。</li></ul><p>3.3 <strong>数据传输优化</strong></p><ul><li>锁页内存的使用及传输延迟优化。</li><li>使用异步传输（hipMemcpyAsync）实现计算与传输的时间重叠。</li></ul><p>3.4 <strong>其他模块优化</strong></p><ul><li>守恒变量与原始变量转换代码的异构移植。</li><li>算法重排以减少数据依赖。</li></ul><hr><h3 id="4-实验与结果"><a href="#4-实验与结果" class="headerlink" title="4. 实验与结果"></a><strong>4. 实验与结果</strong></h3><p>4.1 <strong>实验设置</strong></p><ul><li>硬件环境：CPU和DCU配置。</li><li>测试场景：三维液滴变形与破碎。</li></ul><p>4.2 <strong>性能分析</strong></p><ul><li>优化前后的加速比与运行时间对比。</li><li>数据传输开销对总计算效率的影响。</li></ul><p>4.3 <strong>正确性验证</strong></p><ul><li>模拟结果与理论解的对比。</li><li>多场景验证优化算法的鲁棒性。</li></ul><hr><h3 id="5-结论与展望"><a href="#5-结论与展望" class="headerlink" title="5. 结论与展望"></a><strong>5. 结论与展望</strong></h3><p>5.1 <strong>研究总结</strong></p><ul><li>代码异构移植和性能优化的关键成果。</li></ul><p>5.2 <strong>未来工作</strong></p><ul><li>多节点协同计算扩展。</li><li>针对更复杂多相流场景的适配与优化。</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h3><p>按照目标期刊要求，列出所有相关文献，涵盖背景研究和优化技术。</p><h2 id="项目推进"><a href="#项目推进" class="headerlink" title="项目推进"></a>项目推进</h2><p>加上openmp，利用4个DCU卡算数据，先全部传入，核函数中的循环分段，用多线程调用核函数，调用memcpy</p><p>2024年12月19日20:24:27</p><p>明天好好写论文。</p><p>2025年1月4日17:06:41</p><p>晚上写参考文献，改综述，优化实验部分。</p><p>明后天做实验。openmp</p><p>发现了代码命名错误，但不影响结果，irl 应该是ir1同理jrl,krl都有错误。</p><p>2025年1月5日19:30:55</p><p>数组怎么传入，怎么传回</p><p>对于中间的一些数组来说，imark这种判断数组，每一块DCU中都传入，像中间有所改变但不用传回的数组如Flux_US，下标的取值是不确定的，所以计算Flux_US的代码US先不要用openmp计算，将US的代码在其中一个DCU中计算，计算完Flux_US后将其传入到剩下的三个块中，进行后续的计算。对于flux数组是四维数组，…。像需要传回的数组con,con2,pre等。</p><p>先将all_con_2_prim(将con的值赋值给pre…) 加上openmp计算</p><p>将con,con2,pre…分块传入，找准每个数组要传入的下标范围，每一个dcu中得到各个数组的一块，对这一块进行计算,然后传回。</p><p>先这样，不弄这个了。</p><p>先搞清总体要怎么弄。后期还要做什么优化，。。有个大局观。 烦人。。。</p><p>2025年1月6日14:47:31</p><p>把这一切当成一场历练，而不是gp的任务。</p><p>对于Flux_US按照之前的算，因为传回的时候下标不好找，比较分散</p><p>对于flux Lcon数组，核函数不变，在4张DCU中都传入数组flux Lcon全部的值，然后传回的时候，通过计算偏移量，只传回修改过的数组范围，比如说Flux_x_FVM2中修改了flux[index4Df_ir1 + m]这个范围的值，而Flux_x_FVM3中修改了flux[index4Df + m]这部分范围，相当于对4张卡的值进行合并然后传回。先试试。<br>对于con,con2,pre…等数组，一样<br>有个问题，核函数之间计算完的数据要不要传回cpu，传回的意思是每次执行核函数后都合并更新flux的值，合并完的flux值可能和计算完再合并的flux值不同。因为flux的计算是有顺序的，先按照传回计算。试试可行不。先这样加油！！！</p><p>2025年1月7日16:14:12</p><p>改公式和图，加实验。加点复杂牛逼的图。</p><p>加图，锁页加不同数组的效率提升，数据掩盖不同数组的效率提升。这里就用柱状图和折线图的组合图，多个柱</p><p>横轴：设置为锁页内存的总数据量（MB），纵轴：移植代码时间</p><p>两个柱，分别表示锁页前和锁页后的时间对比，再加一个折线表示加速比。总时间的图保持不变。</p><p>数组掩盖，横轴：传输中被掩盖的总数据量（MB），纵轴：移植代码时间</p><p>同上。</p><p>4个柱</p><p>可视化部分，体现相同的时间迭代步的不同,可视化要体现出加速效果。相同的时间，模拟演化的速度不同。或者是相同的演化，耗费的时间不同。想想咋弄</p><p>明天作图，直接写数据。</p><p><img src="/../images/1736251870606.png" alt="1736251870606"></p><p><img src="/../images/1736251960406.png" alt="1736251960406"></p><p><img src="/../images/1736251981141.png" alt="1736251981141"></p><p><img src="/../images/1736252018929.png" alt="1736252018929"></p><p>2025年1月9日16:57:02</p><p>今天做完ppt，改完论文除了可视化的其他部分，包括图。</p><p>beyond ppt不还随便做嘛。</p><p>论文：逻辑通顺点，双柱状图那里改改。让人看懂。抓紧做完投出去烦死了。。。这是一场历练</p><p>问题：404s,在摘要里面写移植代码加速比，实验部分也要加个移植代码部分的时间和加速比</p><p>all两个数组总共755s，总时间18897s，非移植代码时间4187</p><p>占总时间的4%，占非移植代码时间的18%。这里写的时候写18%</p><p>在算法介绍里面加上各个算法占比，算法各部分占比时间做个饼图，这里写4%，equation求解部分78%，剩下18%（程序初始化1%，推进符号距离方程3%，网格切割并组装11%，计算下一步的界面通量和时间步长3%）。</p><p>双柱状图那里改改，加上一段话，说明加上锁页的内存是什么物理意义（守恒变量，原始变量，通量）。数据量不要这么整齐，用实际的大小，这里计算一下。</p><h3 id="1-几何信息相关"><a href="#1-几何信息相关" class="headerlink" title="1. 几何信息相关"></a>1. <strong>几何信息相关</strong></h3><ul><li><strong>imark</strong>: 26,270,592</li><li><strong>cut_model</strong>: 26,270,592</li><li><strong>cutface</strong>: 26,270,592</li><li><strong>xyzside</strong>: 78,811,776</li><li><strong>cutside</strong>: 72,000,000</li></ul><h3 id="2-网格属性相关"><a href="#2-网格属性相关" class="headerlink" title="2. 网格属性相关"></a>2. <strong>网格属性相关</strong></h3><ul><li><strong>phimac</strong>: 52,541,184</li><li><strong>VOL</strong>: 52,541,184</li><li><strong>dx</strong>: 1,776</li><li><strong>dy</strong>: 1,376</li><li><strong>dz</strong>: 1,376</li><li><strong>area_cutside</strong>: 48,000,000</li></ul><h3 id="3-流体动力学基本变量"><a href="#3-流体动力学基本变量" class="headerlink" title="3. 流体动力学基本变量"></a>3. <strong>流体动力学基本变量</strong></h3><ul><li><strong>den (密度)</strong>: 105,082,368</li><li><strong>pre (压力)</strong>: 105,082,368</li><li><strong>vel_u (速度-x方向)</strong>: 105,082,368</li><li><strong>vel_v (速度-y方向)</strong>: 105,082,368</li><li><strong>vel_w (速度-z方向)</strong>: 105,082,368</li></ul><h3 id="4-流量相关"><a href="#4-流量相关" class="headerlink" title="4. 流量相关"></a>4. <strong>流量相关</strong></h3><ul><li><strong>flux_US (全局通量)</strong>: 240,000,000</li><li><strong>flux_cutface (局部通量)</strong>: 120,000,000</li></ul><h3 id="5-守恒变量"><a href="#5-守恒变量" class="headerlink" title="5. 守恒变量"></a>5. <strong>守恒变量</strong></h3><ul><li><strong>Lcon</strong>: 262,705,920 </li><li><strong>flux</strong>: 262,705,920 </li><li><strong>con (守恒变量数组)</strong>: 788,117,760</li><li><strong>con2 (备用守恒变量数组)</strong>: 788,117,760</li></ul><p><strong>几何信息相关</strong>：与网格切割、边界描述有关的数据。</p><p><strong>网格属性相关</strong>：与网格点体积、面积等特性有关的属性。</p><p><strong>流体动力学基本变量</strong>：描述流体状态的主要物理量，如密度、压力和速度。</p><p><strong>流量相关</strong>：与流体流动量计算相关的数组。</p><p><strong>守恒变量</strong>：主要用于数值求解的守恒量表达，如质量、动量和能量等</p><p>各部分的字节总大小如下（单位：字节）：<br>几何信息（Geometry Information）: 229,623,552 ，218MB<br>网格属性（Grid Properties）: 153,086,896 ，146MB<br>流体动力学变量（Fluid Dynamics Variables）: 525,411,840，501MB<br>通量相关（Flux Related）: 360,000,000，343MB<br>守恒变量（Conserved Variables）: 2,101,647,360 ，2,004MB</p><p>将这些字节大小转换为MB，共3200MB</p><p>ppt没做，其他都做完了</p><p>明天做ppt，然后研究可视化部分</p><p>2025年1月10日19:29:14</p><p>ppt做完了，只剩下可视化</p><p>程序还在跑，看最后一次的结果，Animate看动画。</p><p>2025年1月11日16:06:53</p><p>可视化不行，不好做，不行就不加了。-.-</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project21_split成功all改为核函数</title>
    <link href="/2024/12/14/project21_split%E6%88%90%E5%8A%9Fall%E6%94%B9%E4%B8%BA%E6%A0%B8%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/14/project21_split%E6%88%90%E5%8A%9Fall%E6%94%B9%E4%B8%BA%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>1.将all_con_2_prim.F90  all_prim_2_con.F90 两段代码放在GPU上计算</p><p>2.做一个函数input output 的表</p><p>3.搞明白US Flux_x_FVM依赖关系，才能分块。</p><p>4.fluid &#x3D; 1 算完后能不能传回数据。</p><p>5.写小论文</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="先将all-con-2-prim放在GPU上面并测试"><a href="#先将all-con-2-prim放在GPU上面并测试" class="headerlink" title="先将all_con_2_prim放在GPU上面并测试"></a>先将all_con_2_prim放在GPU上面并测试</h3><p><img src="/../images/1733724808481.png" alt="1733724808481"></p><p><strong>函数中做的操作：</strong></p><p>all_con_2_prim将con的值赋给pre，….</p><p>US_2_S中也将con的值赋给pre…</p><p>后面的函数没有能掩盖传输时间的了。</p><p><strong>目的</strong>：减少all_con_2_prim在cpu上的执行时间（453s），改为在GPU运算(测试时间: 8s )</p><p>增加了传回时间，con和pre（74s）都要传回。</p><p>在执行完eauqation后将con传回，因为all_con_2_prim中要用到con</p><p>执行完all_con_2_prim后将pre…传回,因为US_2_S中要给pre赋值</p><h4 id="1000步中等网格"><a href="#1000步中等网格" class="headerlink" title="1000步中等网格"></a>1000步中等网格</h4><p>之前4612s</p><p><img src="/../images/1733744265844.png" alt="1733744265844"></p><p><img src="/../images/1733744271811.png" alt="1733744271811"></p><h3 id="将all-prim-2-con移植到GPU"><a href="#将all-prim-2-con移植到GPU" class="headerlink" title="将all_prim_2_con移植到GPU"></a>将all_prim_2_con移植到GPU</h3><p>先异步传入pre…和con，con2，然后在gpu上面计算con</p><p>目的：减少all_prim_2_con在cpu上的计算时间(307s),增加了all_prim_2_con核函数的运行时间( 25s)</p><h4 id="1000步中等网格-1"><a href="#1000步中等网格-1" class="headerlink" title="1000步中等网格"></a>1000步中等网格</h4><p><img src="/../images/1733824701903.png" alt="1733824701903"></p><p><img src="/../images/1733824708148.png" alt="1733824708148"></p><h3 id="将Flux-xyz-FVM等分成两个核函数"><a href="#将Flux-xyz-FVM等分成两个核函数" class="headerlink" title="将Flux_xyz_FVM等分成两个核函数"></a>将Flux_xyz_FVM等分成两个核函数</h3><p><img src="/../images/1733824729800.png" alt="1733824729800"></p><p><img src="/../images/1733824737115.png" alt="1733824737115"></p><p>差不多没变化</p><h3 id="输出拆分后（拆分成两个）核函书的时间"><a href="#输出拆分后（拆分成两个）核函书的时间" class="headerlink" title="输出拆分后（拆分成两个）核函书的时间"></a>输出拆分后（拆分成两个）核函书的时间</h3><p><img src="/../images/1734004219791.png" alt="1734004219791"></p><p>二维kernel的时间占大部分。</p><h3 id="拆分成三个"><a href="#拆分成三个" class="headerlink" title="拆分成三个"></a>拆分成三个</h3><p>都是三维线程拓扑</p><p>正确性：正确</p><p>说明这两部分要按照顺序进行，不能分线程算每一个i,这样顺序就乱了。</p><p>即对一个下标的计算赋值顺序本来是123，分线程后变成了231，这样得出的flux值就有错误。</p><p>涉及到对同一个下标赋值，这里相当于和us一样的情况</p><p>把这两个部分分成两个核函数，执行完第一个核函数后进行同步，就没错误了。因为本来的顺序就是先执行条件1，再执行条件2 。</p><p>因为如果是一个核函数，其中对一个下标进行了两次操作，这样就可能产生由于线程执行顺序不同造成的错误</p><p>所以将操作flux的代码分为三个部分。</p><p><img src="/../images/1734007024726.png" alt="1734007024726"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h4><p><img src="/../images/1734072917325.png" alt="1734072917325"></p><h3 id="mark-mb掩盖部分传输时间"><a href="#mark-mb掩盖部分传输时间" class="headerlink" title="mark_mb掩盖部分传输时间"></a>mark_mb掩盖部分传输时间</h3><p>真没有能掩盖的代码了，都要用到con,pre…的值。</p><p>equation中异步传输数组pre…,equation后调用mark_mb，然后添加同步,再执行US_2_S函数</p><p>只有US_2_S函数用到了con,考虑只把用到了con的地方移植，就不用传con的值了。（要传入的数组太多，费力不讨好）。只做mark_mb吧。</p><p>把重点放在核函数的优化上面，分块，stencil ,shared memory.</p><h3 id="分块success"><a href="#分块success" class="headerlink" title="分块success"></a>分块success</h3><p>US算界面上切割网格的通量，物理意义。</p><p>Flux_FVM_US中这段代码是算什么的</p><p>已经在jk方向上是没有顺序的，但是算i的时候必须要按照顺序进行算，不能乱序。</p><p>这里如果两次循环算出来的side值相同的话，会对flux_US的同一个下标进行操作。这样就把前一个算出的flux_US的值覆盖掉。</p><p>我现在做分块，如果i之间有这种依赖的话，就没法分块。</p><p>单个if里面side不相同</p><p>和其他的if里面有相同的side</p><p>把US拆开，分几个if</p><p>顺序是怎样的。</p><p>两个if是有交集的，排斥的不可能</p><p>if ，i+1的和i如果if判断的条件相同，就有可能对一个值进行操作</p><p>分成两块，先算i，再算+1的部分。</p><p><strong>success</strong> ：将ijk 分为一块，将i+1 ,j+1 ,k+1 分为一块，再将之前将两个流体的分块合并起来。成功了，现在us被分成两块了。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="/../images/1734150346109.png" alt="1734150346109"></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project20_split探索</title>
    <link href="/2024/12/08/project20_split%E6%8E%A2%E7%B4%A2/"/>
    <url>/2024/12/08/project20_split%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="测试核函数的时间"><a href="#测试核函数的时间" class="headerlink" title="测试核函数的时间"></a>测试核函数的时间</h2><p><img src="/../images/1732948842064.png" alt="1732948842064"></p><h2 id="分块策略"><a href="#分块策略" class="headerlink" title="分块策略"></a>分块策略</h2><p>挣扎摸索尝试</p><p>核函数计算和con传输重叠。</p><p>如何分块？。。。。。</p><p>xyz之间有顺序吗，改变顺序验证正确性。</p><p>zyx这个顺序有误差。所以不能调整顺序？</p><p>还有顺序，分块后也要按照这个顺序。</p><p>先分块，再重叠。</p><p>分块是分成小的网格块，实现通信计算重叠是在分块的基础上将小的网格块放在不同的流中。</p><p>怎么识别每个块，halo区域处理，边界处理，一个线程算多少，一个线程块算多少，</p><p>分块后：每个块为一个三维的小网格</p><p>对于RK来说，一个线程算一个点</p><p>对于US和Flux_xyz来说，一个线程算一长条</p><p>I can do it !</p><p>不一定有顺序，可能只是依赖</p><p>先看一个分块的例子，搞懂原理。</p><p><img src="/../images/1733292050947.png" alt="1733292050947"></p><p>网格大小为 222,172,172</p><p>数组是<code>[k][j][i]</code></p><p>没有想象的这么难，但是也不简单</p><p><img src="/../images/1733293284665.png" alt="1733293284665"></p><p>分块就是执行完一次核函数后，完成一个小网格通量的计算。</p><p>一个线程块对应一个小网格，多个线程块组成一个大的网格</p><p>每个线程块运行在不同的core上，每个线程块内有共享内存</p><p>一个网格点需要用到周围网格点的数据，7点stencil计算</p><p>一个小网格内，边界的点需要用到周围点的数据。</p><p>边界区域需要小网格之间进行交互。边界区域就是halo区</p><p>问题：这些小网格之间的计算有先后顺序吗？因为计算一个网格的时候需要用临近网格边界区的数据</p><p>那个US算的就是界面上切割网格的通量，它是要用到周围的点的值，感觉不好拆</p><p>Flux_xyz_FVM是求xyz方向数值通量</p><p>后续：</p><p>把Flux_x_FVM拆分，三维并行，二维并行。</p><p>看看halo区stencil的计算，顺序问题？</p><p>计算顺序无所谓，因为halo区中要存放其他线程块边缘的数据，这个数据是input数据，不是算完的数据</p><p>可以简单理解为用到的是输入数据input,算完的数据是output。有没有顺序无所谓。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>2024年12月6日14:01:30</p><p>策略，先把Flux_x_FVM拆分，三维并行，二维并行。</p><p>分块策略：分成小的网格块。单对着一个小网格块进行分析：对于us来说，二维拓扑，每个线程处理一长条。</p><p>对于Flux_xyz_FVM来说，三维的部分，每个线程处理一个网格点，二维的部分每个网格也是处理一长条。</p><p>对于RK来说，已经分块了。</p><p>计算顺序，加上同步，核函数之间是有顺序的。us计算完毕的flux_US数组要在xyz核函数中用到。</p><p>然后分块，没有halo区（肯定有错误），最后设置halo区</p><p>边界区域可以在cpu算 ,</p><p>us呢？时间占比很少，也可以在cpu算，但是us是stencil计算？</p><h2 id="各函数计算任务"><a href="#各函数计算任务" class="headerlink" title="各函数计算任务"></a>各函数计算任务</h2><p><img src="/../images/1733554549386.png" alt="1733554549386"></p><p><strong>Flux_FVM_US</strong>：用den,pre,vel_u,vel_v,vel_w数组算 flux_US（边界上切割网格的通量 ）</p><p><strong>Flux_x_FVM，Flux_y_FVM，Flux_z_FVM</strong>：先计算xyz方向数值通量flux,再用flux计算Lcon</p><p>1先用den,pre,vel_u,vel_v,vel_w计算<strong>内部</strong>对应网格的flux</p><p>2然后对<strong>边界</strong>两侧一层网格做特殊处理，用flux_US给flux赋值</p><p>3最后算完flux后，用flux计算Lcon（下一个时刻的信息）</p><p><strong>RK</strong>：用flux_US和Lcon计算con，con2</p><p>imark&#x3D;&#x3D;0是边界，＞1或＜-1是内部的网格；&#x3D;&#x3D;±1就是边界两侧一层网格</p><p>然后imark&#x3D;&#x3D;0或±1都要用flux_US来特殊计算</p><p>分块：</p><p>拆分Flux_x_FVM，核函数为2D,3D kernel </p><p>Flux_FVM_US也是2D kernel </p><p>2D kernel 中 i 要按照顺序计算，怎么分块。US和Flux_x_FVM</p><p>边界上的计算有顺序</p><p>RK是3D kernel</p><p>计算分块后的小网格，一个block算一个小网格，确保2D,3D kernel 对应线程号在同一个block中</p><p>halo区</p><p>all_con_2_prim计算位置</p><p>理解错了，分块并不是整体分块，而是在对一个核函数分块。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project19_异步传输</title>
    <link href="/2024/11/26/project19_%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/11/26/project19_%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="提前传输数组，异步传输，单个默认流"><a href="#提前传输数组，异步传输，单个默认流" class="headerlink" title="提前传输数组，异步传输，单个默认流"></a>提前传输数组，异步传输，单个默认流</h1><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>传cut_model(istep&#x3D;1和其他情况，在不同的函数中，再讨论)</p><p>提前传入了很多数组，并在equation代码前面添加了gpu同步</p><p>hipDeviceSynchronize()</p><p><img src="/../images/1732272679268.png" alt="1732272679268"></p><p>都没问题，没有误差</p><p>测试1000轮中等网格</p><p>5078s(before)</p><p><img src="/../images/1732325894070.png" alt="1732325894070"></p><p>4994s</p><p><img src="/../images/1732325856126.png" alt="1732325856126"></p><h2 id="流设置为几个比较好"><a href="#流设置为几个比较好" class="headerlink" title="流设置为几个比较好"></a>流设置为几个比较好</h2><p>一个，减少cpu对流操作的开销，只使用默认流</p><h2 id="con提前计算并传输"><a href="#con提前计算并传输" class="headerlink" title="con提前计算并传输"></a>con提前计算并传输</h2><p>(没在GPU中算，直接提前算(将all_prim_2_con提前)，然后传输)</p><p>con来回传输占比3152</p><p>总占比4,184</p><p>其他数组 1032</p><p>1032&#x2F;4184 &#x3D; 24%</p><p><img src="/../images/1732272950318.png" alt="1732272950318"></p><p>如果能再gpu中算，就不用传输con的值了，数组大小和用到的范围是关键点。</p><p>可以提前算，提前传，把con的计算传输提前</p><p>改完没误差</p><p>性能如下</p><p>before:5078s</p><p><img src="/../images/1732325894070.png" alt="1732325894070"></p><p>1个流（默认流）4550s </p><p><img src="/../images/1732342303998.png" alt="1732342303998"></p><p>描述不一定对。</p><p>memcpy少了400s,少了的时间就是这些数组（大部分数组）之前传入的时间、</p><p>con，con2大约占220s，所以剩下的423秒里面传回cpu的con,con2占220s,还有200s是常量的时间。</p><p>总时间少了500s，还有100s是cpu减少的时间</p><p>2个流 4726s</p><p><img src="/../images/1732342321256.png" alt="1732342321256"></p><p>4个流 4761s</p><p><img src="/../images/1732342334473.png" alt="1732342334473"></p><p>将不变的常量和dx,dy,dz在循环前传入</p><p>没误差</p><p>测试</p><p>19234（fortran）</p><p>4538s</p><p><img src="/../images/1732353663748.png" alt="1732353663748"></p><p>插桩，找到耗时的时间</p><h2 id="插桩测试"><a href="#插桩测试" class="headerlink" title="插桩测试"></a>插桩测试</h2><p>1000步中等网格</p><p><strong>fortran</strong></p><p>总时间  18897s</p><p>移植代码时间 14710s</p><p>非移植代码时间 4187s</p><p><strong>异步前：hip14</strong></p><p><img src="/../images/1732531567660.png" alt="1732531567660"></p><p><img src="/../images/1732531549518.png" alt="1732531549518"></p><p><img src="/../images/1732531575014.png" alt="1732531575014"></p><p>总时间  ：5250s</p><p>移植代码时间 806s</p><p>非移植代码时间 4,444s</p><p><strong>异步后（cpu计算和传输重叠）：hip17</strong></p><p>总时间 4814s</p><p>移植代码时间 404s</p><p>非移植代码时间 4,410s(cpu计算时间完全覆盖掉了memcpy时间)</p><p><img src="/../images/1732531630278.png" alt="1732531630278"></p><p><img src="/../images/1732531641943.png" alt="1732531641943"></p><p><img src="/../images/1732531664246.png" alt="1732531664246"></p><p>gettimeofday</p><h3 id="再测试计算时间，添加同步（之前测的有误）"><a href="#再测试计算时间，添加同步（之前测的有误）" class="headerlink" title="再测试计算时间，添加同步（之前测的有误）"></a>再测试计算时间，添加同步（之前测的有误）</h3><h4 id="RK后面添加一个同步"><a href="#RK后面添加一个同步" class="headerlink" title="RK后面添加一个同步"></a>RK后面添加一个同步</h4><p>异步前</p><p><img src="/../images/1732610574329.png" alt="1732610574329"></p><p><img src="/../images/1732610589067.png" alt="1732610589067"></p><p>异步后</p><p><img src="/../images/1732601611522.png" alt="1732601611522"></p><p><img src="/../images/1732601618708.png" alt="1732601618708"></p><h4 id="在每个核函数后面都添加同步"><a href="#在每个核函数后面都添加同步" class="headerlink" title="在每个核函数后面都添加同步"></a>在每个核函数后面都添加同步</h4><p>异步前</p><p><img src="/../images/1732617101121.png" alt="1732617101121"></p><p><img src="/../images/1732617114718.png" alt="1732617114718"></p><p>异步后</p><p><img src="/../images/1732608015678.png" alt="1732608015678"></p><p><img src="/../images/1732608035878.png" alt="1732608035878"></p><p> 总结：有些传输时间没法和cpu计算掩盖，这一部分可以通过分块来实现掩盖</p><p>下一步测试各个数组的传输时间，看一下哪部分数组能掩盖。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project18(con必须传入，申请释放一次，gpu数组直接赋值)</title>
    <link href="/2024/11/18/project18(con%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%85%A5%EF%BC%8C%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E4%B8%80%E6%AC%A1%EF%BC%8Cgpu%E6%95%B0%E7%BB%84%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC)/"/>
    <url>/2024/11/18/project18(con%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%85%A5%EF%BC%8C%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E4%B8%80%E6%AC%A1%EF%BC%8Cgpu%E6%95%B0%E7%BB%84%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC)/</url>
    
    <content type="html"><![CDATA[<h3 id="对con数组的操作，减少传输"><a href="#对con数组的操作，减少传输" class="headerlink" title="对con数组的操作，减少传输"></a>对con数组的操作，减少传输</h3><p><strong>d_con都设置为0，然后传回的时候只传回修改的部分，这样就减少了con传入gpu的memcpy时间</strong></p><p><img src="/../images/1731730333252.png" alt="1731730333252"></p><p><img src="/../images/1731730339857.png" alt="1731730339857"></p><p><code>con[3][172][172][222][5]</code></p><p>在gpu里面更改的范围</p><p><img src="/../images/1731730950856.png" alt="1731730950856"></p><p><code>下标con[0-2][3-168][3-168][3-218][0-4]</code></p><p>d_con  &#x3D; 0  </p><p>然后只需要把这一部分传回即可</p><p><code>3*((*kbnd_R) * (*jbnd_R) * (*ibnd_R) * 5) + k * ((*jbnd_R) * (*ibnd_R) * 5) + j * ((*ibnd_R) * 5) + i * 5;</code></p><p><code>(c1*(*kbnd_R) * (*jbnd_R) * (*ibnd_R) + k * (*jbnd_R) * (*ibnd_R) + j * (*ibnd_R) + i )*5</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">(c1*(*kbnd_R) * (*jbnd_R) * (*ibnd_R) + k * (*jbnd_R) * (*ibnd_R) + j * (*ibnd_R) + i )*<span class="hljs-number">5</span><br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">3</span>; c++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = kbnd_L1 - <span class="hljs-number">1</span>; k &lt;= kbnd_R1 - <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = jbnd_L1 - <span class="hljs-number">1</span>; j &lt;= jbnd_R1 - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ibnd_L1 - <span class="hljs-number">1</span>; i &lt;= ibnd_R1 - <span class="hljs-number">1</span>; i++) &#123;<br>                    <span class="hljs-comment">// 偏移</span><br>                    <span class="hljs-type">int</span> offset = (c*(*kbnd_R) * (*jbnd_R) * (*ibnd_R) + k * (*jbnd_R) * (*ibnd_R) + j * (*ibnd_R) + i )*<span class="hljs-number">5</span>;<br><br>                    <span class="hljs-comment">// 一次性传输 [c][k][j][i][0:4]，即第五维大小 C5 的数据</span><br>                    <span class="hljs-built_in">cudaMemcpy</span>(&amp;con[offset], &amp;d_con[offset], <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>), cudaMemcpyDeviceToHost);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这样调用的memcpy次数太多了</p><p>改为将没有更改的部分传入，传回的时候只需要传回整个数组</p><p>传整个con的时间为</p><p><img src="/../images/1731918932401.png" alt="1731918932401"></p><p>将边界传入的时间为</p><p><img src="/../images/1731919095236.png" alt="1731919095236"></p><p>只传con有误差，不可行。</p><p><strong>con大结局！！！</strong></p><p><img src="/../images/1731920959871.png" alt="1731920959871"></p><p>con用到了自己的值，必须要传进来。</p><h3 id="gpu变量申请释放一次"><a href="#gpu变量申请释放一次" class="headerlink" title="gpu变量申请释放一次"></a>gpu变量申请释放一次</h3><p>在循环体外面声明，并在外面释放。</p><p>性能测试1000轮中等网格</p><p>之前 5321s</p><p><img src="/../images/1731925918273.png" alt="1731925918273"></p><p>申请释放一次后 5430s</p><p>去掉三个数组后 5078s</p><p><img src="/../images/1731937726798.png" alt="1731937726798"></p><h3 id="实现计算传输重叠（no-do-it-）"><a href="#实现计算传输重叠（no-do-it-）" class="headerlink" title="实现计算传输重叠（no do it ）"></a>实现计算传输重叠（no do it ）</h3><p>分块怎么分，涉及到的数组太多，数组的大小维度不同</p><p>每一块的内存连续问题</p><p>如果要保证每一块的内存都是连续的，没法算</p><p>如果要分块，在内存中肯定是不连续的，不连续怎么传？分段memcpy</p><p>好像不能分块,必须传入全部的数据。计算过程中需要使用连续的i,连续的j,连续的k.</p><p>&#x2F;&#x2F;可以把不好分块的数组先全部传进来，只对容易分块的数组进行分块。</p><p>核函数有必要合并吗，目前没必要。</p><p>&#x2F;&#x2F;后期扩展到多卡上，分块又要重新分</p><p>&#x2F;&#x2F;传输掩盖了计算的时间后，还对计算进行优化吗？</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project17(mps尝试和计算通信时间重叠后续思路)</title>
    <link href="/2024/11/15/project17(mps)/"/>
    <url>/2024/11/15/project17(mps)/</url>
    
    <content type="html"><![CDATA[<h3 id="con传入dcu是否可以省略"><a href="#con传入dcu是否可以省略" class="headerlink" title="con传入dcu是否可以省略"></a>con传入dcu是否可以省略</h3><p>con也不能省略，会有误差</p><p>con2不能省略，会有错误。将con2初始值设置为0会有错误。可能要用到con2的值吧，先不考虑了。</p><p>所以con，con2还是要传入才行。</p><p>这里省略了的意思是，d_con,d_con2都为0。但是有些值不能设置为0</p><h3 id="优化补充"><a href="#优化补充" class="headerlink" title="优化补充"></a>优化补充</h3><h4 id="pinned补充和memset赋值"><a href="#pinned补充和memset赋值" class="headerlink" title="pinned补充和memset赋值"></a>pinned补充和memset赋值</h4><p>将之前没设置为pinned的数组设置为pinned,并给它们赋值的时候采用memset函数（更高效）</p><p>flux_US,flux,Lcon,flux_cutside.</p><p>25轮没有误差</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>5025轮中等网格：26556s</p><p>之前：28809s</p><p>1000轮中等网格：5321</p><p>之前：5653</p><h3 id="计算数组的大小"><a href="#计算数组的大小" class="headerlink" title="计算数组的大小"></a>计算数组的大小</h3><p>为了便于数据量的分配，必须计算数组的大小。</p><p>以中等网格为例</p><p><img src="/../images/1731225842706.png" alt="1731225842706"></p><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><p> ibnd_R         222<br> jbnd_R         172<br> kbnd_R         172<br> Max_cutface_num     3000000<br> Max_side_num     6000000<br> Max_cutface_num     3000000</p><p> fortran size_3D     6567648<br> fortran size_xyzside    19702944<br> fortran size_cutside    18000000<br> fortran size_Lcon    32838240<br> fortran size_flux_US    30000000<br> fortran size_con    98514720<br> fortran size_flux_cutface    15000000<br> fortran size_den    13135296</p><h4 id="计算大小："><a href="#计算大小：" class="headerlink" title="计算大小："></a>计算大小：</h4><p><strong>16个数组，总共大小：</strong></p><h5 id="int-57-405-888（219M）"><a href="#int-57-405-888（219M）" class="headerlink" title="int:57,405,888（219M）"></a>int:57,405,888（219M）</h5><p>单位为数组大小</p><p>imark：6567648，26,270,592</p><p>cut_model：6567648，26,270,592</p><p>cutface:6567648，26,270,592</p><p>xyzside:19702944，78,811,776</p><p>cutside:18000000，72,000,000</p><h5 id="double-392-518-262-2995M-2-92G"><a href="#double-392-518-262-2995M-2-92G" class="headerlink" title="double:392,518,262 (2995M,2.92G)"></a>double:392,518,262 (2995M,2.92G)</h5><p>phimac:6567648 ，52,541,184</p><p>VOL:6567648，52,541,184</p><p>dx:222，1,776</p><p>dy:172，1,376</p><p>dz:172，1,376</p><p>area_cutside:6000000，48,000,000</p><p>thread1:386,000,000</p><p>den:13135296，105,082,368</p><p>pre:13135296，105,082,368</p><p>vel_u:13135296，105,082,368</p><p>vel_v:13135296，105,082,368</p><p>thread2:420</p><p>vel_w:13135296，105,082,368</p><p>flux_US:30,000,000，240,000,000</p><p>flux_cutface:15,000,000，120,000,000</p><p>thread3:465</p><p>Lcon:32,838,240，262,705,920</p><p>flux:32,838,240，262,705,920</p><p>thread4:525</p><p>con:98514720，788,117,760</p><p>thread5,6:394</p><p>con2:98514720，788,117,760</p><p>thread7,8:394</p><h4 id="手动分组："><a href="#手动分组：" class="headerlink" title="手动分组："></a>手动分组：</h4><p>起8个线程</p><p>3368&#x2F;8 &#x3D; 421,000,000</p><p><img src="/../images/1731392053516.png" alt="1731392053516"></p><p>#SBATCH –ntasks-per-node&#x3D;10</p><p>#SBATCH –cpus-per-task&#x3D;1</p><p><strong>传回的两个数组：1,503M（1.46G）</strong></p><p>con:98514720</p><p>con2:98514720</p><h2 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="demo测试8个线程"><a href="#demo测试8个线程" class="headerlink" title="demo测试8个线程"></a>demo测试8个线程</h3><h4 id="不加"><a href="#不加" class="headerlink" title="不加"></a>不加</h4><p>#SBATCH –ntasks-per-node&#x3D;8</p><p>#SBATCH –cpus-per-task&#x3D;1</p><p><img src="/../images/1731393477020.png" alt="1731393477020"></p><h4 id="加上"><a href="#加上" class="headerlink" title="加上"></a>加上</h4><p><img src="/../images/1731393500273.png" alt="1731393500273"></p><h4 id="一个任务两个cpu核"><a href="#一个任务两个cpu核" class="headerlink" title="一个任务两个cpu核"></a>一个任务两个cpu核</h4><p>#SBATCH –ntasks-per-node&#x3D;8</p><p>#SBATCH –cpus-per-task&#x3D;2</p><p>同时要设置两个dcu卡</p><p>#SBATCH –gres:dcu&#x3D;2</p><p><img src="/../images/1731393703877.png" alt="1731393703877"></p><h3 id="3D-cutcell测试"><a href="#3D-cutcell测试" class="headerlink" title="3D-cutcell测试"></a>3D-cutcell测试</h3><p><strong>中等网格1000轮</strong></p><h4 id="什么也不加"><a href="#什么也不加" class="headerlink" title="什么也不加"></a>什么也不加</h4><p>5321s</p><p><img src="/../images/1731475603778.png" alt="1731475603778"></p><h4 id="加上openmp后"><a href="#加上openmp后" class="headerlink" title="加上openmp后"></a>加上openmp后</h4><p><img src="/../images/1731475633149.png" alt="1731475633149"></p><h5 id="不加-1"><a href="#不加-1" class="headerlink" title="不加"></a>不加</h5><p>#SBATCH –ntasks-per-node&#x3D;8</p><p>#SBATCH –cpus-per-task&#x3D;1</p><p>5354s</p><h5 id="加上-1"><a href="#加上-1" class="headerlink" title="加上"></a>加上</h5><p>5201s</p><p>去掉hipStreamSyn同步，改用hipDeviceSyn替代：5234s</p><p><img src="/../images/1731475546662.png" alt="1731475546662"></p><p>正确性验证</p><p>25轮没问题</p><h5 id="两个cpu核"><a href="#两个cpu核" class="headerlink" title="两个cpu核"></a>两个cpu核</h5><p>5424</p><p><strong>中等网格5025轮</strong></p><p>加上</p><p>#SBATCH –ntasks-per-node&#x3D;8</p><p>#SBATCH –cpus-per-task&#x3D;1</p><p>27410s</p><p>还慢了</p><p>The reason？</p><p>写demo测试一下，对比memcpy和其他函数的时间</p><h4 id="对比hipperf函数时间"><a href="#对比hipperf函数时间" class="headerlink" title="对比hipperf函数时间"></a>对比hipperf函数时间</h4><p>之前</p><p><img src="/../images/1731467049782.png" alt="1731467049782"></p><p>加上openmp后</p><p><img src="/../images/1731467070574.png" alt="1731467070574"></p><p>hipStreamSynchronize的时间占用的很多</p><p>去掉hipStreamSyn同步，改用hipDeviceSyn替代</p><h4 id="200步中等网格测试"><a href="#200步中等网格测试" class="headerlink" title="200步中等网格测试"></a>200步中等网格测试</h4><p>pinned后</p><p><img src="/../images/1731479179196.png" alt="1731479179196"></p><p>去掉同步后</p><p><img src="/../images/1731482129268.png" alt="1731482129268"></p><p>openmp后，并去掉所有的同步</p><p><img src="/../images/1731479198112.png" alt="1731479198112"></p><p>将全部的hipmemcpy都分线程后</p><p><img src="/../images/1731482857003.png" alt="1731482857003"></p><p>只创建销毁一次流</p><p><img src="/../images/1731486217222.png" alt="1731486217222"></p><p>潜在的同步，还是流传输的同步时间，只不过加到了别的函数时间上，总时间没有差别。</p><p>还是写demo，分别测，加上openmp到底有没有效果。再应用到程序里面。</p><p>不用测了，说明pcie总线信道已经被占满了，分线程也没用，因为一个线程可能就占满了传输信道。</p><h2 id="后续任务"><a href="#后续任务" class="headerlink" title="后续任务"></a>后续任务</h2><p>感觉有点扯。先传一部分，传完进行计算，在计算的时候再传另一部分。实现传输和计算的重叠。</p><p>就相当于把网格分为几部分。但是怎么分呢？</p><p>为什么要合并核函数？没搞懂。不合并行不行？有必要吗？</p><p>把一次要处理的核函数放在一个流中，保证计算的顺序，就不需要合并了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>代码不用改，只改要传输的数组块即可，就是每次计算要用到数组的哪一部分。</p><p>由于内核对所有元素都是独立操作的，因此每个块都可以独立处理。</p><p>可就是核函数中处理的是数组的一个下标或多个下标（称为块）。可以单独运行。</p><p>传输了数组的哪部分内容，就计算哪块。不用改核函数。</p><p>重点是对多个数组进行分块传输，用流。</p><p>流1计算的时候流2可以进行数据传输。</p><p>con没必要全传入</p><p><img src="/../images/1731664373029.png" alt="1731664373029"></p><p><img src="/../images/1731664387717.png" alt="1731664387717"></p><p>这些值在RK里面会被初始化为新的值。</p><p>也就是说在equation中，只改了这一部分的值。</p><p>所以，不用传入d_con（默认为0）,只需将d_con更改的地方（也就是这个范围的值）传回。</p><p>不要传其他的值。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project16(锁页性能测试)</title>
    <link href="/2024/11/05/project16(%E9%94%81%E9%A1%B5%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95)/"/>
    <url>/2024/11/05/project16(%E9%94%81%E9%A1%B5%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95)/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么要测试"><a href="#为什么要测试" class="headerlink" title="为什么要测试"></a>为什么要测试</h3><p>找到具体哪个地方影响了性能</p><h3 id="测试规格"><a href="#测试规格" class="headerlink" title="测试规格"></a>测试规格</h3><p>100步</p><p>网格大小</p><p><img src="/../images/1730099702888.png" alt="1730099702888"></p><h3 id="不同代码测试"><a href="#不同代码测试" class="headerlink" title="不同代码测试"></a>不同代码测试</h3><p>通过测试发现单步Memcpy的时间并没有提升多少。</p><h4 id="不设置锁页内存"><a href="#不设置锁页内存" class="headerlink" title="不设置锁页内存"></a>不设置锁页内存</h4><p><img src="/../images/1730100724513.png" alt="1730100724513"></p><h4 id="全部设置为锁页内存，gpu快了，影响了cpu的效率"><a href="#全部设置为锁页内存，gpu快了，影响了cpu的效率" class="headerlink" title="全部设置为锁页内存，gpu快了，影响了cpu的效率"></a>全部设置为锁页内存，gpu快了，影响了cpu的效率</h4><p><img src="/../images/1730099783736.png" alt="1730099783736"></p><h4 id="只将con设置为锁页内存，gpu不变-cpu快了"><a href="#只将con设置为锁页内存，gpu不变-cpu快了" class="headerlink" title="只将con设置为锁页内存，gpu不变,cpu快了"></a>只将con设置为锁页内存，gpu不变,cpu快了</h4><p><img src="/../images/1730101565750.png" alt="1730101565750"></p><h4 id="再加上flux-flux-US-Lcon-没有影响"><a href="#再加上flux-flux-US-Lcon-没有影响" class="headerlink" title="再加上flux flux_US Lcon 没有影响"></a>再加上flux flux_US Lcon 没有影响</h4><p><img src="/../images/1730102552574.png" alt="1730102552574"></p><h4 id="再加上-den-pre-vel-uvw-几乎没有影响"><a href="#再加上-den-pre-vel-uvw-几乎没有影响" class="headerlink" title="再加上 den pre vel_uvw 几乎没有影响"></a>再加上 den pre vel_uvw 几乎没有影响</h4><p><img src="/../images/1730103490488.png" alt="1730103490488"></p><h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>直接分配锁页内存和分配完再注册的效率不一样，写一个小的程序进行测试。</p><p>效率一样的，都有一倍的提升</p><p>可以再写一个fortran代码测试。</p><p>现在用的是gfortran编译器gcc version 11.2.0 (conda-forge gcc 11.2.0-16)  旧版的不能识别iso_c_binding.</p><p><img src="/../images/1730205926606.png" alt="1730205926606"></p><p>释放还有问题</p><p>先测试memcpy的时间</p><p>再写一个正常的分页内存代码，作对比。</p><p>today work is over(2024年10月29日20:55:40)</p><p>2024年10月30日17:53:55</p><p>内存分配失败，乱，bad code.</p><p>指针是好的，传给数组就有问题了。</p><p>no matter，is not a trouble ,don’t to be sad,I will fix it.</p><p>2024年10月31日17:14:29</p><p>move_alloc 数组到数组 可以直接在c中定义数组，分配数组，然后通过函数将内存传入fortran的数组</p><p>target可以被修改？改了这个然后，输出错误不一样了。看一下</p><p>f_array输出的是值，不是地址，让他输出地址。  </p><p>2024年11月1日14:00:41</p><p>释放有错误，<strong>说明给h_locked_ptr分配内存的时候就失败了</strong></p><p>target真正的用法，两个都要加还是被关联的要加？-&gt;的时候才要加</p><p>分配成功了，就是不能内存传给数组</p><p><strong>可能是size的问题了</strong>，分配一个下标</p><p>size改为指针，还有f_c 函数的其他用法，32很奇怪</p><p>在fortran给指针分配内存，然后用函数将内存传给数组，证明函数的正确性。</p><p><img src="/../images/1730518629236.png" alt="1730518629236"></p><p>10 （40）差48</p><p>12（48） 差64</p><p>14（56） 差 64</p><p>16（64）差 80</p><p>应该是分配的内存大小和数组需要的内存大小不一致，导致的错误。</p><p>从fortran传过去的指针，锁页和普通时间都一样</p><p>尝试从c中分配指针，然后传给fortran</p><p>释放内存，把指针定义在module 里面</p><p>直接在c中分配完成后进行测试，锁页要快</p><p>但是传给fortran后性能差不多</p><p>锁页成功 ctof</p><h3 id="真正的锁页性能测试"><a href="#真正的锁页性能测试" class="headerlink" title="真正的锁页性能测试"></a>真正的锁页性能测试</h3><p>加上了大部分数组</p><p>没加：Lcon ,flux,flux_US,flux_cutface,flux_cutface.</p><p>因为申请锁页内存HipHostMalloc 占用的时间较大，这几个数组到后面再考虑加上。</p><h5 id="不申请锁页（225步-大网格【上面那个网格】，不加输出代码）"><a href="#不申请锁页（225步-大网格【上面那个网格】，不加输出代码）" class="headerlink" title="不申请锁页（225步 大网格【上面那个网格】，不加输出代码）"></a>不申请锁页（225步 大网格【上面那个网格】，不加输出代码）</h5><p>225个迭代步 </p><p>不加锁页 Total runtime: 1500 seconds</p><p>Cpu time 940s</p><p>GPU time 560s</p><p>Memcpy time : 474s</p><p><img src="/../images/1730721323673.png" alt="1730721323673"></p><h5 id="申请锁页（同上）"><a href="#申请锁页（同上）" class="headerlink" title="申请锁页（同上）"></a>申请锁页（同上）</h5><p>加锁页 Total runtime: 1309 seconds</p><p>Cpu time 979s</p><p>GPU time 330s</p><p>Memcpy time : 229s</p><p><img src="/../images/1730721349123.png" alt="1730721349123"></p><h4 id="正确性验证"><a href="#正确性验证" class="headerlink" title="正确性验证"></a>正确性验证</h4><p>25步输出结果没问题</p><h3 id="fortran申请锁页内存和使用中遇到的问题"><a href="#fortran申请锁页内存和使用中遇到的问题" class="headerlink" title="fortran申请锁页内存和使用中遇到的问题"></a>fortran申请锁页内存和使用中遇到的问题</h3><p>调用c函数，在c中调用hip函数申请锁页内存。直接在c中创建指针，将指针返回给fortran，不要在fortran中以形参的形式将指针传给c。传给c后，通过c_to_pointer，转换指针类型，然后再c_to_pointer转换为三维数组指针。</p><p>ctof这个demo里面有例子。</p><p>配合use, intrinsic :: iso_c_binding使用</p><p>在定义c函数接口的时候，也要写上这句代码。</p><p>目前就想到这么多要注意的。</p><p>也是一点点测试出来的，easy.</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>做不锁页和锁页的折线图</p><h3 id="相同网格不同迭代步数（用中等网格做，步数：500-1000，2000-3000，4000-5000）"><a href="#相同网格不同迭代步数（用中等网格做，步数：500-1000，2000-3000，4000-5000）" class="headerlink" title="相同网格不同迭代步数（用中等网格做，步数：500,1000，2000,3000，4000,5000）"></a>相同网格不同迭代步数（用中等网格做，步数：500,1000，2000,3000，4000,5000）</h3><p>两条线：锁页和不锁页</p><p>横坐标：步数</p><p>纵坐标：加速比</p><h3 id="相同步数不同网格数（小，中，大网格，1000步）"><a href="#相同步数不同网格数（小，中，大网格，1000步）" class="headerlink" title="相同步数不同网格数（小，中，大网格，1000步）"></a>相同步数不同网格数（小，中，大网格，1000步）</h3><p>两条线：锁页和不锁页</p><p>横坐标：网格大小</p><p>纵坐标：加速比</p><h4 id="小网格"><a href="#小网格" class="headerlink" title="小网格"></a>小网格</h4><p>xpointsA &#x3D; 8<br>xpointsB &#x3D; 100<br>xpointsC &#x3D; 8</p><p>ypointsA &#x3D; 4<br>ypointsB &#x3D; 75<br>ypointsC &#x3D; 4</p><p>zpointsA &#x3D; 4<br>zpointsB &#x3D; 75<br>zpointsC &#x3D; 4</p><h4 id="中等网格"><a href="#中等网格" class="headerlink" title="中等网格"></a>中等网格</h4><p>xpointsA &#x3D; 8<br>xpointsB &#x3D; 200<br>xpointsC &#x3D; 8</p><p>ypointsA &#x3D; 8<br>ypointsB &#x3D; 150<br>ypointsC &#x3D; 8</p><p>zpointsA &#x3D; 8<br>zpointsB &#x3D; 150<br>zpointsC &#x3D; 8</p><p>锁页</p><h4 id="大网格"><a href="#大网格" class="headerlink" title="大网格"></a>大网格</h4><p>xpointsA &#x3D; 8<br>xpointsB &#x3D; 400<br>xpointsC &#x3D; 8</p><p>ypointsA &#x3D; 8<br>ypointsB &#x3D; 300<br>ypointsC &#x3D; 8</p><p>zpointsA &#x3D; 8<br>zpointsB &#x3D; 300<br>zpointsC &#x3D; 8</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>中等网格：</p><p><img src="/../images/1731155307550.png" alt="1731155307550"></p><p>1000步：</p><p><img src="/../images/1731155314062.png" alt="1731155314062"></p><p>大网格还没测，一张dcu卡的显存不够</p><h3 id="零拷贝内存"><a href="#零拷贝内存" class="headerlink" title="零拷贝内存"></a>零拷贝内存</h3><p>使用零拷贝内存的情况：在一大块主机内存中，只使用少量的数据。</p><p><strong>准确来说，零拷贝并不是无需拷贝，而是无需显式拷贝</strong>。使用零拷贝内存时不需要cudaMemcpy之类的显式拷贝操作，直接通过指针取值，所以对调用者来说似乎是没有拷贝操作。但实际上是在引用内存中某个值时隐式走PCIe总线拷贝，这样的方式有几个优点：</p><p> 无需所有数据一次性显式拷贝到设备端，而是引用某个数据时即时隐式拷贝</p><p> 隐式拷贝是异步的，可以和计算并行，隐藏内存传输延时</p><h4 id="针对本代码，可以使用零拷贝的数组"><a href="#针对本代码，可以使用零拷贝的数组" class="headerlink" title="针对本代码，可以使用零拷贝的数组"></a>针对本代码，可以使用零拷贝的数组</h4><p>flux_cutface:只用了一次</p><p>先不考虑，先把大的优化做完。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project15（锁页内存初尝试）</title>
    <link href="/2024/10/25/project15%EF%BC%88%E9%94%81%E9%A1%B5%E5%86%85%E5%AD%98%E5%88%9D%E5%B0%9D%E8%AF%95%EF%BC%89/"/>
    <url>/2024/10/25/project15%EF%BC%88%E9%94%81%E9%A1%B5%E5%86%85%E5%AD%98%E5%88%9D%E5%B0%9D%E8%AF%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Equation’s-time-of-all-time"><a href="#Equation’s-time-of-all-time" class="headerlink" title="Equation’s time of all time"></a>Equation’s time of all time</h3><p>fortran 最初的大网格 单线程，225步（没加输出.plt 的代码）</p><p><img src="/../images/1729664480198.png" alt="1729664480198"></p><p><img src="/../images/1729664464177.png" alt="1729664464177"></p><p><img src="/../images/1729664438507.png" alt="1729664438507"></p><p>占比80%</p><h3 id="锁页内存"><a href="#锁页内存" class="headerlink" title="锁页内存"></a>锁页内存</h3><p>1直接分配锁内存有错误，显示分配失败</p><p>2采用第二种方法：将已有的内存注册为锁内存</p><p>之前：1437s</p><p><img src="/../images/1729858847603.png" alt="1729858847603"></p><p>用了锁业内存后：1473s</p><p><img src="/../images/1729858898507.png" alt="1729858898507"></p><p>还慢了。。。</p><p>Memcpy快了一点(10s)，但总体时间慢了（50s），cpu时间增多了(60s)</p><p>影响的是cpu的效率，因为分配了锁页内存，说明这两种方法的效率是差不多的。</p><p>就不试直接分配了，费力不讨好。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>多个cpu核心同时传输</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些idea</title>
    <link href="/2024/10/18/%E4%B8%80%E4%BA%9Bidea/"/>
    <url>/2024/10/18/%E4%B8%80%E4%BA%9Bidea/</url>
    
    <content type="html"><![CDATA[<p>一些idea，思考才会让人进步</p><h3 id="理想中的博客"><a href="#理想中的博客" class="headerlink" title="理想中的博客"></a>理想中的博客</h3><p>超算也就这些东西，涉及的东西很多很深。</p><p><a href="https://zhuanlan.zhihu.com/p/600489819">漫谈高性能计算与性能优化：访存 - 知乎</a></p><h3 id="关于毕业和工作"><a href="#关于毕业和工作" class="headerlink" title="关于毕业和工作"></a>关于毕业和工作</h3><p>我不可能学完所有的东西，时间也不够 。如果超算真的是未来的趋势的话，这无非是最好的选择。</p><p>我真的喜欢这个领域吗？成年人还谈什么喜欢。挺喜欢的说实话，坚持下来吧，挺有趣的。</p><p>明年今日，静待花开。</p><p>1.不想成为什么样的人？</p><p>堕落的人</p><p>2.想过什么样的生活？</p><p>充满爱与挑战，有价值的人生。</p><p>3.人终会死去，而这一切又有什么意义？我来这一趟是为了什么？</p><p>爱人，被爱。</p><p>4.如何保持内心的平静？</p><p>不要为任何事情感到焦虑，它只会让我更加强大。</p><h3 id="关于在做的项目（方案思路）："><a href="#关于在做的项目（方案思路）：" class="headerlink" title="关于在做的项目（方案思路）："></a>关于在做的项目（方案思路）：</h3><p>基于网格点并行（RK）和基于网格线（US,x,y,z）并行两种并行方案进行移植</p><p>然后再使用多种优化方法：核函数的合并与分解，使用共享内存，寄存器，调整线程块大小。</p><p>合并内存访问</p><p>减少bank冲突</p><p>计算和访存的合并（double buffer）:一个warp在访存的时候，另一个warp在计算，通过warp切换来掩盖访存的开销。但是双缓冲需要双倍的存储空间来存储额外的数据。</p><p>保证负载均衡：每个block（warp）和线程处理的数据量是均衡的。</p><p>核函数的合并和分解（牵扯到每个线程的寄存器大小，充分利用寄存器资源）</p><p>但是寄存器资源非常稀少，所以当核函数过大，中间变量过多时，可以采用拆分核函数的方法，减少同一个核函数内寄存器的使用数量，从而增大线程块并发的数量。当核函数规模较小，中间变量较少，则可以将相关核函数进行合并，在保证线程块具有较高并行性的情况下，充分利用寄存器资源。</p><p>合并内存访问</p><h4 id="减少数据传输"><a href="#减少数据传输" class="headerlink" title="减少数据传输"></a>减少数据传输</h4><p>锁页内存</p><p>批量，合并传输</p><p><a href="https://zhuanlan.zhihu.com/p/188246455">【遇见CUDA】要更快，请提高数据传输效率！ - 知乎</a></p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>2024年10月19日21:31:18</p><p>赶个ppt出来</p><p>再测一下传输和计算的时间</p><p>不同网格移植代码所占用的时间不同。网格越大，占比越大，因为要算的数据增多了。</p><h4 id="小网格"><a href="#小网格" class="headerlink" title="小网格"></a>小网格</h4><p><img src="/../images/1729494379116.png" alt="1729494379116"></p><p>移植代码部分：</p><p>fortran: 470s<br>hipc: 135 s</p><p>加速比：3.48</p><p>fortran移植代码占比，65%（225步）</p><p>hipc移植代码占比，34%（225步）</p><p>时间快了，占比肯定少了。</p><h4 id="大网格"><a href="#大网格" class="headerlink" title="大网格"></a>大网格</h4><p><img src="/../images/1729494385570.png" alt="1729494385570"></p><p>移植代码部分时间：</p><p>fortran: 3345<br>hipc: 575 s</p><p>加速比：5.8</p><p>fortran移植代码占比，77%（225步）</p><p>hipc移植代码占比，40%（225步）</p><h3 id="后续任务"><a href="#后续任务" class="headerlink" title="后续任务"></a>后续任务</h3><p><img src="/../images/1729500951625.png" alt="1729500951625"></p><p>减少memcpy时间</p><h4 id="teachers-’s-help-thanks"><a href="#teachers-’s-help-thanks" class="headerlink" title="teachers ’s help ,thanks !"></a>teachers ’s help ,thanks !</h4><p>写论文的时候用饼图表示时间占比更直观（优化部分时间占总时间的比例）。</p><p>并不是基于网格点或基于网格线并行，就是stencil计算。</p><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>stencil(模型)：3Dblocks(重点)，算存比，算法特征，</p><p>建立性能模型：roofline等</p><p>计算优化： 访存优化，缓存，LDS（共享内存）设计,设置合理线程数量，进行数据隐藏</p><p>尽可能算多的block，保证资源利用率</p><p>减少数据传输时间（Memcpy）:锁页内存，cpu,gpu协同异步传输（多个cpu核对一个gpu）</p><p>计算替代传输（后面再考虑）</p><p>改RK：这一步归到算法设计，再找袁老师改。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java线程锁</title>
    <link href="/2024/10/16/java%E7%BA%BF%E7%A8%8B%E9%94%81/"/>
    <url>/2024/10/16/java%E7%BA%BF%E7%A8%8B%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>就是synchronized</p><p><img src="/../images/1729058796803.png" alt="1729058796803"></p><p><img src="/../images/1729059532022.png" alt="1729059532022"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket03</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<span class="hljs-comment">//让多个线程共享 ticketNum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">loop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//控制 run 方法变量</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//这里相当于类的一个成员变量，三个线程访问的是一个object对象</span><br><span class="hljs-comment">//非静态同步代码块</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//this object 都可以</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-comment">/*this*/</span> object) &#123;<br>        <span class="hljs-comment">//如果这里改为 new Object()就不对了，三个线程访问的就不是一个对象了</span><br><span class="hljs-keyword">if</span> (ticketNum &lt;= <span class="hljs-number">0</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;售票结束...&quot;</span>);<br>loop = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//静态同步代码块</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//只能用 类.class</span><br><span class="hljs-keyword">synchronized</span> (SellTicket03.class) &#123;<br>System.out.println(<span class="hljs-string">&quot;m2&quot;</span>);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">//静态方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="/../images/1729059550594.png" alt="1729059550594"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-comment">//死锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DeadLockDemo</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockDemo</span>(<span class="hljs-literal">true</span>);<br>        A.setName(<span class="hljs-string">&quot;A线程&quot;</span>);<br>        <span class="hljs-type">DeadLockDemo</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLockDemo</span>(<span class="hljs-literal">false</span>);<br>        B.setName(<span class="hljs-string">&quot;B线程&quot;</span>);<br>        A.start();<br>        B.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">//保证多个线程共享一个数据对象，这里使用static，如果不加static就不是一个对象了。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">boolean</span> flag;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DeadLockDemo</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">synchronized</span> (o1) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到o1对象锁 &quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到o2对象锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (o2) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到o2对象锁&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;拿到o1对象锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><h4 id="释放锁的情况"><a href="#释放锁的情况" class="headerlink" title="释放锁的情况"></a>释放锁的情况</h4><p><img src="/../images/1729061986818.png" alt="1729061986818"></p><h4 id="不释放锁的情况"><a href="#不释放锁的情况" class="headerlink" title="不释放锁的情况"></a>不释放锁的情况</h4><p><img src="/../images/1729061999962.png" alt="1729061999962"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java线程插队守护状态同步</title>
    <link href="/2024/10/15/java%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F%E5%AE%88%E6%8A%A4%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
    <url>/2024/10/15/java%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F%E5%AE%88%E6%8A%A4%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>不要让时间磨平了你的棱角</p><p>I enjoy it , so do it. </p><p>真不知道毕业后何去何从了，看了看嵌入式。</p><p>学无止境啊。先搞懂Java吧</p><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p><img src="/../images/1728977037055.png" alt="1728977037055"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><span class="hljs-comment">//join线程插队</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadJoin</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">T5</span> <span class="hljs-variable">t5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T5</span>();<br>        t5.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">20</span> ; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;主线程吃了&quot;</span>+i+<span class="hljs-string">&quot;个包子&quot;</span>);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">5</span>)&#123;    <br>                t5.join();<br>                <span class="hljs-comment">//yield不一定礼让成功</span><br>                <span class="hljs-comment">//t5.yield();</span><br>            &#125;              <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T5</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;子线程吃了&quot;</span>+i+<span class="hljs-string">&quot;个包子&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><img src="/../images/1728979292421.png" alt="1728979292421"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><span class="hljs-comment">//守护线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadDaemon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Daemon</span> <span class="hljs-variable">daemon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Daemon</span>();<br>        <span class="hljs-comment">//把子线程设置为守护线程，然后执行。这句话要在执行前面。</span><br>        daemon.setDaemon(<span class="hljs-literal">true</span>);<br>        daemon.start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;work&quot;</span>+(i));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Daemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//无限循环</span><br>        <span class="hljs-keyword">for</span>(; ;)&#123;<br>            System.out.println(<span class="hljs-string">&quot;chat&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程七大状态"><a href="#线程七大状态" class="headerlink" title="线程七大状态"></a>线程七大状态</h3><p><img src="/../images/1728981170208.png" alt="1728981170208"></p><h4 id="线程调度图"><a href="#线程调度图" class="headerlink" title="线程调度图"></a>线程调度图</h4><p><img src="/../images/1728981191742.png" alt="1728981191742"></p><p><strong>之所以说七个状态是因为，runnable中包括ready(就绪态)和running(运行态),这个是由内核调度的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><span class="hljs-comment">/*查看线程状态</span><br><span class="hljs-comment">查看一个子线程从创建到运行再到结束的状态</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadState</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">State</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>();<br>        System.out.println(t.getName()+<span class="hljs-string">&quot;&quot;</span>+t.getState());<br>        t.start();<br>        <span class="hljs-keyword">while</span>(t.getState()!= Thread.State.TERMINATED)&#123;<br>            System.out.println(t.getName()+<span class="hljs-string">&quot;&quot;</span>+t.getState());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(t.getName()+<span class="hljs-string">&quot;&quot;</span>+t.getState());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;hi&quot;</span>+i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/../images/1728981373113.png" alt="1728981373113"></p><h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><p><img src="/../images/1728995546940.png" alt="1728995546940"></p><p>处理买票问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.ticket;<br><span class="hljs-comment">//利用线程同步机制处理买票问题，保证不超卖</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sell</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">sellTicket</span> <span class="hljs-variable">sellTicket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">sellTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sellTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;售票结束&quot;</span>);<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;售票员&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了一张票，剩余的票数为&quot;</span> + (--count));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>            sell();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project14</title>
    <link href="/2024/10/14/project14/"/>
    <url>/2024/10/14/project14/</url>
    
    <content type="html"><![CDATA[<h3 id="测试的时间还是在project08-里面"><a href="#测试的时间还是在project08-里面" class="headerlink" title="测试的时间还是在project08 里面"></a>测试的时间还是在project08 里面</h3><p>时间占用问题，用hipprof测的移植部分比重变小了,2025步是40%</p><p>可能还有其他的函数占比，hipprof没测出来。</p><h3 id="重心"><a href="#重心" class="headerlink" title="重心"></a>重心</h3><p>1技术技术技术(important）</p><p>2.看论文</p><p>3.cfd的代码慢慢啃吧（参考）</p><h3 id="改成传输一次（把equation合并在一起）"><a href="#改成传输一次（把equation合并在一起）" class="headerlink" title="改成传输一次（把equation合并在一起）"></a><strong>改成传输一次</strong>（把equation合并在一起）</h3><p>us改了flux_US的值，flux_US在xyz和RK中都要用。</p><p>xyz 改了flux和Lcon的值。</p><p>RK改了con的值。</p><p>flux flux_US Lcon 还需要传回来吗？</p><p>看一下后面的代码</p><p>应该只改了con,con2这两个数组</p><p>flux_cutface 和 flux_cutface2的值也没变</p><p>只用到了flux_cutface的值,所以，flux_cutface2不用传入</p><p>这两个数组都不用传回来。</p><p><strong>225步</strong></p><p>没改之前：830s</p><p>改为一个Equation：</p><p>663s(直接跑)</p><p>795s,706s（hipprof）<br>输出占75s *2 &#x3D; 150s</p><h3 id="后续思路"><a href="#后续思路" class="headerlink" title="后续思路"></a>后续思路</h3><p>为什么传入的次数减半，时间并没有减少（测步数多一点试试，输出占的时间太多了）</p><p>把同步去掉试试。</p><p>去掉检查check函数</p><p>常量只需在第一次传入即可，用if实现</p><p>con用不用传入，给他赋初值都是0试试有没有错误</p><p>怎么进一步减少<strong>传输时间</strong>？memcpy</p><p><strong>计算时间</strong>已经很少了，加速了很多倍。（这个地方再优化也就那样了）</p><p>测cpu和gpu 分别的时间，感觉hipprof不是很准</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project13</title>
    <link href="/2024/10/11/project13/"/>
    <url>/2024/10/11/project13/</url>
    
    <content type="html"><![CDATA[<p>再测试单独用us一个核函数有没有错误。</p><p>夸张，到底是什么错误。</p><p>单独用一个us也有错误。</p><p>就是us的错误吗，为什么之前测试的时候没有错误。</p><p>懂了，之前测试的是us没有中断的错误，但是有误差的错误。</p><p><strong>所以误差还是us产生的，我确定</strong></p><p>ijk的范围有错误吗，没有</p><p>代码也一样，到底是哪的错误呢？</p><p>把下标计算放到if里面呢？经验证，不是这的错误</p><p>计算flux_US的的时候，下标之间有联系，不能分开算？</p><p><strong>确实有顺序。</strong></p><p>怎么解决，解决不了。</p><p><img src="/../images/1728637700603.png" alt="1728637700603"></p><p>在所有的side计算之后，输出side</p><p>能看到有相同的side，这样就导致访问flux_US数组冲突。从而产生误差。</p><p>我真是天才。</p><p>通过输出side的值可以看出，相同的side值都是挨得很近的，所以可能只有i之间存在相同的side值</p><p><strong>然后把us设置为二维线程拓扑，us的一个线程处理所有的i</strong></p><p>dcu的利用率很低。</p><p>225轮没有误差了，终于成功了。</p><p><img src="/../images/1728644105440.png" alt="1728644105440"></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project12</title>
    <link href="/2024/10/08/project12/"/>
    <url>/2024/10/08/project12/</url>
    
    <content type="html"><![CDATA[<p>225轮</p><p>hipc（xyz,rk四个核函数）</p><p><strong>加上输出</strong>:868s</p><p>输出部分为：868-598 &#x3D; 270s</p><p><strong>没加输出</strong>：598s</p><p>移植的部分（dcu部分）：330s(数据传输，同步)+40s（计算） &#x3D; 370s</p><p>其他的在cpu运行的时间：598-370 &#x3D; 228s</p><p><img src="/../images/1728372609809.png" alt="1728372609809"></p><p><img src="/../images/1728372657102.png" alt="1728372657102"></p><p>us加不上啊，有误差</p><p>不加也行。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project11</title>
    <link href="/2024/10/07/project11/"/>
    <url>/2024/10/07/project11/</url>
    
    <content type="html"><![CDATA[<p>误差问题</p><p>把Flux_x改成一维c，误差还是存在，说明不是x的问题</p><p>可能是数据传输中出了问题。</p><p>先消除误差，找找哪个环节出了问题。</p><p>只添加一个x，没问题</p><p>把yz也改了</p><p>之前测的是加上US和xyz的任意一个就有错误（2024年10月11日16:12:56 这里描述有错误，之前有错误是程序中断，不是误差问题。这样看来还是US出现问题导致的误差）</p><p>应该是中间值的传递错误。</p><p>xy一起 ok</p><p>xyz一起 ok</p><p>xyz RK一起 ok</p><p>4个核函数没问题了。</p><p>性能也有提升。时间测试在project08里面</p><p>所以说今天还是有收获的。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project10</title>
    <link href="/2024/09/23/project10/"/>
    <url>/2024/09/23/project10/</url>
    
    <content type="html"><![CDATA[<p>忘了从什么时候开始了，今天上传一下吧。</p><h3 id="debug-continue"><a href="#debug-continue" class="headerlink" title="debug continue"></a>debug continue</h3><p>输出con con.txt</p><p>在第一次计算完con的时候输出，发现结果一样</p><p>所以说计算没问题，数据传输的过程中出了问题</p><p>也不一定，RK &#x3D; 2 的时候还没输出。</p><p>输出RK &#x3D; 2 计算后的con con1.txt</p><p>也没问题</p><p>所以是传输的问题。</p><p>到第二轮的时候传出错了？</p><p>输出第二轮RK &#x3D; 1 con的值。 con2.txt 误差很小</p><p>输出第二轮RK &#x3D; 2 con的值，con3.txt 误差很小</p><p>输出第三轮RK &#x3D; 1 con的值 ,  con4.txt  误差很小</p><p>输出第三轮RK &#x3D; 2 con的值 ,  输出不了</p><p>istep &#x3D; 3 RK &#x3D; 1 走完。</p><p>istep &#x3D; 3 RK &#x3D; 2 的时候 经过Level_equation 程序断了</p><p>在Level_equation上面输出 con5 误差很小</p><p><img src="/../images/1726743891267.png" alt="1726743891267"></p><p><code>vel_w[2][ibnd_R][jbnd_R][kbnd_R]</code></p><p>istep &#x3D; 3 RK &#x3D; 2 的时候,在Level_equation上面输出vel_w(2,i,j,k)       velw.txt</p><p><img src="/../images/1726744739022.png" alt="1726744739022"></p><p>vel_w 算错了</p><p>看看第一轮vel_w的值算对了没。 </p><p>istep &#x3D; 1 RK &#x3D; 2 时 velw1.txt 算对了</p><p>istep &#x3D; 2 RK &#x3D;1 时 velw2.txt  算对了</p><p>istep &#x3D; 2 RK &#x3D;2 时 velw3.txt  不对</p><p><img src="/../images/1726746211264.png" alt="1726746211264"></p><p>找到具体被改的位置</p><p><img src="/../images/1726748170663.png" alt="1726748170663"></p><p>vel_w 是在 istep &#x3D; 2 ,RK &#x3D; 1时， 执行完Equation被改的。</p><p>就在这几个位置</p><p>在all_con_2_prim 上面输出 velw4.txt 对</p><p>在all_con_2_prim 下面输出 velw5.txt  错</p><p><img src="/../images/1726748992859.png" alt="1726748992859"></p><p>所以vel_w 是在 istep &#x3D; 2 ,RK &#x3D; 1时，在all_con_2_prim中     velw的值被改了</p><p><img src="/../images/1726749093536.png" alt="1726749093536"></p><p>输出con 和con2的值</p><p>之前测过con的值没问题，那就是con2的问题了。</p><p>在Equation后输出</p><p>输出第二轮RK &#x3D; 1 con2的值，con2.txt 误差很小</p><p>con 和 con2 的值都没毛病 ，那是怎么回事</p><p>在all_con_2_prim 下面输出 con con2 ….wait</p><p>在同样的位置，再输出con2的值，算误差 con2_1.txt 对</p><p>输出 con 的值 con_1.txt 对</p><p>只能是dv了啊，</p><p><img src="/../images/1726751718993.png" alt="1726751718993"></p><p>在all_con_2_prim前面输出</p><p>dx,dy,dz ,dxyz.txt完全相同，没有误差</p><p>奇怪了。</p><p>明天再测vel_w的值在哪里错的，用err计算</p><p>istep &#x3D;2 ,RK &#x3D; 1</p><p>在all_con_2_prim上面输出 vel_w6.txt 完全相同</p><p>在下面输出 vel_w7.txt 不对了</p><p><img src="/../images/1726811467197.png" alt="1726811467197"></p><p>前面验证con和con2的值都没有错误，只能看imark 了</p><p>在all_con_2_prim前输出imark的值 <code>imark[ibnd_R][jbnd_R][kbnd_R] </code>    imark1.txt</p><p>imark 完全相同</p><p><img src="/../images/1726812665000.png" alt="1726812665000"></p><p><img src="/../images/1726812630792.png" alt="1726812630792"></p><p><img src="/../images/1726812675039.png" alt="1726812675039"></p><p><img src="/../images/1726812638239.png" alt="1726812638239"></p><p>在all上面输出vel_w(1,i,j,k)的值  v1.txt 完全相同</p><p>在all下面输出vel_w(1,i,j,k)的值  v2.txt </p><p><img src="/../images/1726813751837.png" alt="1726813751837"></p><p>由于RK &#x3D;1 ，再输出con(4,i,j,k,2)的值和con(1,i,j,k,2)的值</p><p>con(1,i,j,k,2) con3.txt  完全相同</p><p>con(4,i,j,k,2) con4.txt  误差很小</p><p>con2(1,i,j,k,2) con5.txt  误差很小</p><p>con2(4,i,j,k,2) con6.txt  误差很小</p><p>在all上面输出vel_w(2,i,j,k)的值  v3.txt 完全相同</p><p>在all下面输出vel_w(2,i,j,k)的值  v4.txt  误差很大（应该就是这里的错误了）</p><p>输出v8找到误差最大值的下标。</p><p><strong>vel_w(2,47,58,4)</strong></p><p>con2(4,47,58,4,2) </p><p><img src="/../images/1726820856229.png" alt="1726820856229"></p><p><img src="/../images/1726820860676.png" alt="1726820860676"></p><p>con2(1,47,58,4,2) </p><p><img src="/../images/1726821057524.png" alt="1726821057524"></p><p>一样的</p><p><strong>vel_w(2,48,58,56)</strong> 误差最大的下标</p><p>c</p><p><img src="/../images/1726823350957.png" alt="1726823350957"></p><p>hipc</p><p><img src="/../images/1726823368568.png" alt="1726823368568"></p><p>con2(4,48,58,56,2)</p><p><img src="/../images/1726822860604.png" alt="1726822860604"></p><p><img src="/../images/1726822871588.png" alt="1726822871588"></p><p>con2(1,48,58,56,2)</p><p><img src="/../images/1726822640104.png" alt="1726822640104"></p><p><img src="/../images/1726822645076.png" alt="1726822645076"></p><p>dx dy dz </p><p><img src="/../images/1726823555654.png" alt="1726823555654"></p><p>122 ,89,89</p><p>7921</p><p>377453 %  372287 &#x3D; 5166</p><p>377453 &#x2F;  372287 &#x3D; 47</p><p>5166 &#x2F;89 &#x3D; 58</p><p>5166 % 89 &#x3D; 4</p><p><img src="/../images/1726816194526.png" alt="1726816194526"></p><p><img src="/../images/1726816253348.png" alt="1726816253348"></p><p>再回到上面的代码</p><p><img src="/../images/1726816277693.png" alt="1726816277693"></p><p>con2(1,i,j,k,2) con5.txt  误差很小</p><p>con2(4,i,j,k,2) con6.txt  误差很小</p><p>看不出来</p><p>在prim后面</p><p>输出具体下标的值 vel_w</p><p><img src="/../images/1726816747350.png" alt="1726816747350"></p><p><img src="/../images/1726816988622.png" alt="1726816988622"></p><p><img src="/../images/1726816992998.png" alt="1726816992998"></p><p>输出con2(1,32,49,36,2)</p><p><img src="/../images/1726817399595.png" alt="1726817399595"></p><p><img src="/../images/1726817413229.png" alt="1726817413229"></p><p>输出con2(4,32,49,36,2)</p><p><img src="/../images/1726817580413.png" alt="1726817580413"></p><p><img src="/../images/1726817588306.png" alt="1726817588306"></p><p>c:</p><p><img src="/../images/1726824408942.png" alt="1726824408942"></p><p>hipc:</p><p><img src="/../images/1726824424522.png" alt="1726824424522"></p><p>每一次出错的下标不同</p><p>一起输出</p><p><img src="/../images/1726829003927.png" alt="1726829003927"></p><p><img src="/../images/1726828627572.png" alt="1726828627572"></p><p>c：</p><p><img src="/../images/1726828958979.png" alt="1726828958979"></p><p>hipc：</p><p><img src="/../images/1726828964290.png" alt="1726828964290"></p><p>把RK改成一维c，还是同样的错误，说明错误不在这，还是前面算的有错误。</p><p>con被其他数组的值赋值了。</p><p>先启动一个核函数试试。</p><p>US ok</p><p>改了x （US 和 x一起）</p><p><img src="/../images/1726909700605.png" alt="1726909700605"></p><p>x就算错了</p><p>在测试一下RK是不是有错误</p><p>x用一维c，US，RK设为核函数</p><p>US和RK一起没问题</p><p>再测试一下US RK z 有错误</p><p><img src="/../images/1726914905250.png" alt="1726914905250"></p><p>再测试一下US RK y 有错误</p><p><img src="/../images/1726915883217.png" alt="1726915883217"></p><p>US and x</p><p>算误差 25次 ，误差很大</p><p>xyz代码都有bug。</p><p>bug类型应该是一样的</p><p><strong>flux的赋值有两次，又先后顺序的，分了线程后，顺序可能不同了。结果就不同。这里有点绕。</strong></p><p>改成一个if里面两个If分支还是有错误。</p><p><strong>正常顺序是</strong></p><p>a[0]  &#x3D; 0,a[1] &#x3D;2 ,a[2] &#x3D; 3</p><p>给当前下标赋值，再给下一个下标赋值。</p><p><strong>当前的顺序是</strong></p><p>第一个线程给他的下标赋值完后a[0]  &#x3D;0 ，再给下一个下标赋值a[1] &#x3D; 1</p><p>第二个线程给他的下标赋值a[1] &#x3D; 2完后，再给下一个下标赋值a[2] &#x3D; 3</p><p>这两步是没有顺序的</p><p>如果第二步在第一步上面的话</p><p>a[0] &#x3D; 0,a[1] &#x3D;1 ,a[2]&#x3D;3 </p><p>给数组赋的值不对了。</p><p>怎么改，保证正确性。</p><p>线程都给自己的下标赋完值后同步。</p><p>a[0] &#x3D; 0,a[1] &#x3D;2 然后同步</p><p>a[1] &#x3D;1 ,a[2] &#x3D;3 ,a[0] &#x3D; 0</p><p>这样也是错的。</p><p>一个线程操作一个k和j，i使用循环。试一下，感觉应该可以。</p><p>有误差</p><p><img src="/../images/1727096755797.png" alt="1727096755797"></p><p>不知道什么原因。。。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project09</title>
    <link href="/2024/09/18/project09/"/>
    <url>/2024/09/18/project09/</url>
    
    <content type="html"><![CDATA[<h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><p>又跑不了了</p><p>没加–gres&#x3D;dcu:1 到底是怎么跑的？</p><p>又要调程序了</p><p><img src="/../images/1726555776800.png" alt="1726555776800"></p><p>32 ,20 ,28</p><p>和之前的错误一样，f,s数组的问题。</p><p>hip只输出了一次，c输出了两次？</p><p>什么原因让它只循环了一次？</p><p>RK。。</p><p>跑了一次因为在第一次RK &#x3D; 1 的时候就中断了，没有执行到RK &#x3D; 2 的时候</p><p>所以要排查只需要在RK &#x3D; 1 时。</p><p>在all_con输出没问题，输出的是vel(1,…)的值没问题。</p><p>回溯</p><p><img src="/../images/1726643126511.png" alt="1726643126511"></p><p><img src="/../images/1726643150619.png" alt="1726643150619"></p><p><img src="/../images/1726643165698.png" alt="1726643165698"></p><p><img src="/../images/1726643175707.png" alt="1726643175707"></p><p>以上这几个数组的值有问题</p><p><img src="/../images/1726643704132.png" alt="1726643704132"></p><p>在dt_interfaceflux中输出这几个数组的值。</p><p>c:</p><p><img src="/../images/1726643932163.png" alt="1726643932163"></p><p>hipc:</p><p><img src="/../images/1726643940089.png" alt="1726643940089"></p><p>可以看出</p><p><img src="/../images/1726643962490.png" alt="1726643962490"></p><p>这几个值的问题</p><p>在con中输出</p><p><img src="/../images/1726645184448.png" alt="1726645184448"></p><p>没问题</p><p>只能说明在中间这些值被改了，被其他数组赋值了，这些数组又和其他的数组有关。</p><p>在boundary的开头输出</p><p>c:</p><p><img src="/../images/1726645676833.png" alt="1726645676833"></p><p>hipc:</p><p><img src="/../images/1726645682635.png" alt="1726645682635"></p><p><img src="/../images/1726645701312.png" alt="1726645701312"></p><p>所以值在US中被改了</p><p>US中</p><p><img src="/../images/1726645863744.png" alt="1726645863744"></p><p><img src="/../images/1726645904700.png" alt="1726645904700"></p><p>一个值一个值看</p><p>du_star<img src="/../images/1726646004345.png" alt="1726646004345"></p><p>可以传回来后输出con的值</p><p>输出f:con(2,i,j,k,2)的值</p><p>比较两个文件</p><p>数组大小。fortran</p><p><code>double con[5][*ibnd_R][*jbnd_R][*kbnd_R][3]</code></p><p>输出整个con的值</p><p>c</p><p><img src="/../images/1726659855687.png" alt="1726659855687"></p><p>hipc</p><p><img src="/../images/1726659862452.png" alt="1726659862452"></p><p>0 变为 1263，还有其他的值。</p><p>先看这个一个下标的变化。</p><p>c:<code>con[0][3][3][3][0]</code></p><h3 id="find-the-error"><a href="#find-the-error" class="headerlink" title="find the error"></a>find the error</h3><p>验证后，发现con没传回来</p><h3 id="error-again"><a href="#error-again" class="headerlink" title="error again"></a>error again</h3><p>改完之后能运行两步</p><p><img src="/../images/1726661885258.png" alt="1726661885258"></p><p><img src="/../images/1726661899485.png" alt="1726661899485"></p><p><img src="/../images/1726661962743.png" alt="1726661962743"></p><p>再输出con的值</p><p>明天再找吧，我是debug之神，这个错误很好排查。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程02</title>
    <link href="/2024/09/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/"/>
    <url>/2024/09/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B02/</url>
    
    <content type="html"><![CDATA[<h3 id="通知线程退出"><a href="#通知线程退出" class="headerlink" title="通知线程退出"></a>通知线程退出</h3><p>在主线程中控制子线程的变量实现子线程退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadExit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T3</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T3</span>();<br>        t3.start();<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠10s&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        &#125;<br>        t3.setFlag(<span class="hljs-literal">false</span>);<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;第&quot;</span>+(++count)+<span class="hljs-string">&quot;次&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFlag</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadInterrupt</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T4</span> <span class="hljs-variable">t4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T4</span>();<br>        t4.setName(<span class="hljs-string">&quot;bing&quot;</span>);<br>        t4.setPriority(Thread.MIN_PRIORITY);<br>        t4.start();<br>        System.out.println(<span class="hljs-string">&quot;主线程休眠5s&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//提前终止子线程的休眠，让子线程继续运行。</span><br>        t4.interrupt();<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span> ; i++) &#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;看了&quot;</span>+i+<span class="hljs-string">&quot;页书&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线程细节"><a href="#线程细节" class="headerlink" title="线程细节"></a>线程细节</h3><p><img src="/../images/1726475060804.png" alt="1726475060804"></p><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><img src="/../images/1726474988275.png" alt="1726474988275"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project08</title>
    <link href="/2024/09/15/project08/"/>
    <url>/2024/09/15/project08/</url>
    
    <content type="html"><![CDATA[<h3 id="逐个函数测试"><a href="#逐个函数测试" class="headerlink" title="逐个函数测试"></a>逐个函数测试</h3><p>hipus没问题。</p><p>Flux_x  没问题</p><p>Flux_yz 没问题</p><p>RK 也没问题</p><p>成功了？</p><p>跑5025步试试</p><p>真没问题了</p><p>具体问题不知道，改为fluidone 和 fluidtwo 分开释放gpu变量就可以了。</p><h4 id="thread-和-block-数目"><a href="#thread-和-block-数目" class="headerlink" title="thread 和 block 数目"></a>thread 和 block 数目</h4><p><img src="/../images/1726390505156.png" alt="1726390505156"></p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p><img src="/../images/1726390536881.png" alt="1726390536881"></p><h4 id="5025轮后的误差"><a href="#5025轮后的误差" class="headerlink" title="5025轮后的误差"></a>5025轮后的误差</h4><h3 id="测时间"><a href="#测时间" class="headerlink" title="测时间"></a>测时间</h3><h4 id="225轮"><a href="#225轮" class="headerlink" title="225轮"></a>225轮</h4><p><strong>fortran单线程</strong>：971 seconds</p><p><strong>fortran多线程</strong>（开了移植代码部分的openmp）</p><p>16线程：2314 s</p><p>32线程：</p><p>48线程：</p><p><strong>多维c</strong>：875 s</p><p><strong>一维c</strong>：859 s</p><p><strong>hipcc</strong>：</p><p><img src="/../images/1728877817070.png" alt="1728877817070"></p><p>核函数xyz（二维拓扑）：786s</p><p> 核函数xyz（二维拓扑）RK（三维拓扑）：863s</p><p>核函数us,xyz（二维拓扑）RK（三维拓扑）:897s</p><p>改为一个equation后：663s</p><p><img src="/../images/1728877821569.png" alt="1728877821569"></p><p>核函数us,xyz（二维拓扑）RK（三维拓扑）:854s</p><p><img src="/../images/1728879348146.png" alt="1728879348146"></p><p>核函数us,xyz（二维拓扑）RK（三维拓扑）：848s</p><p><img src="/../images/1728885904189.png" alt="1728885904189"></p><p>核函数us,xyz（二维拓扑）RK（三维拓扑）：830s</p><p><img src="/../images/1728885927477.png" alt="1728885927477"></p><p>有错误</p><h4 id="2025轮"><a href="#2025轮" class="headerlink" title="2025轮"></a>2025轮</h4><p><strong>fortran</strong>:</p><p>单线程：7907s</p><p>2个线程：</p><p><strong>一维c</strong>：7248s</p><p><img src="/../images/1728895734760.png" alt="1728895734760"></p><p><strong>hipc 5个核函数：</strong>6865s(移植代码占比40%)</p><p><img src="/../images/1728904797637.png" alt="1728904797637"></p><p><strong>hipc改为一个equation后：</strong></p><p>5098s</p><h4 id="5025轮"><a href="#5025轮" class="headerlink" title="5025轮"></a>5025轮</h4><p>fortran单线程：</p><p>fortran多线程：</p><p>多维c：</p><p>一维c：</p><p>hipcc：</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project07</title>
    <link href="/2024/09/14/project07/"/>
    <url>/2024/09/14/project07/</url>
    
    <content type="html"><![CDATA[<p>fortran跑的时间也和之前不一样了，好抽象。快了不少。时间为之前的40%。线程数的问题。</p><p> <strong>FORTRAN:</strong></p><p>max_tstep &#x3D; 101   pg 12 threads  15h </p><p>max_tstep &#x3D; 101   pg  1 threads    7h</p><p>单线程比多线程要快</p><p>max_tstep &#x3D; 101   pg  12 threads   15h正常了</p><p>max_tstep &#x3D; 11   pg  12 threads  15h</p><p>和max_tstep多大没关系，这个是输出文件的次数</p><p> no pg 1 threads  5h大约</p><p>没有pg后变快了 </p><p> no pg 12 threads  12h大约 9s</p><p> no pg 48 threads  24大约</p><p>线程数越多越慢。。。</p><p><strong>hipc</strong>：</p><p><img src="/../images/1726194188049.png" alt="1726194188049"></p><p>之前跑通的时候用的这个卡</p><p>可以指定哪一个节点跑吗？怀疑是节点的问题，但可能性不大。</p><p>我可能改过输出语句，所以跑不了了？</p><p>用之前成功的节点跑也不行，所以和节点没关系。</p><p><img src="/../images/1726207940044.png" alt="1726207940044"></p><p>查看是否是同步的问题，也就是dcu完全算完之后再传给cpu，cpu完成后再执行dcu。</p><p>多加点同步</p><p>验证25次的输出是否和f一致</p><p>256 去掉不必要的注释后 第一轮输出算错,a.txt</p><p>128 也算错了</p><p>256 能加的地方全部加上同步<code>hipDeviceSynchronize()</code> 还是发散了。</p><h4 id="find-the-bug"><a href="#find-the-bug" class="headerlink" title="find the bug"></a>find the bug</h4><p>不知道哪个环节出了问题。</p><p>跑一步，然后输出，比较fortran and hipc</p><p>用diff找差别。</p><p>保证第一步是对的就可以</p><p>设置RK1，只循环一次。用128足够了</p><p>验证了一维c程序，25轮还有误差。一维程序就不对。。。</p><p>但之前是怎么跑通的，是错觉吗？</p><h4 id="验证一维c的正确性"><a href="#验证一维c的正确性" class="headerlink" title="验证一维c的正确性"></a>验证一维c的正确性</h4><p>再测一遍，不对</p><p>用多维的c测一遍。</p><p>多维的没问题。duo.txt</p><p>慢慢往里面加。</p><p>Flux_x 没问题</p><p>Flux_y 有问题</p><p>Flux_z 也有问题</p><p>看代码看不出什么问题</p><p>check一下</p><p>先从y开始，设置RK&#x3D;1 ,Fluid &#x3D; 1.</p><p>check Lcon</p><p>多维和一维</p><p>fluid &#x3D; 1 Lcon 相同</p><p>flux1 也相同，所以flux2也相同</p><p>fluid &#x3D; 1 时没问题。</p><p>fluid &#x3D; 2 </p><p>Lcon diff后不同。</p><p>flux1 相同</p><p>flux2也相同</p><p><img src="/../images/1726302824553.png" alt="1726302824553"></p><p>那这样只能是dy 的问题了。</p><p>dy也没问题</p><p><img src="/../images/1726303204587.png" alt="1726303204587"></p><p><img src="/../images/1726303207829.png" alt="1726303207829"></p><p>？？</p><p>这个咋弄的</p><p>+&#x3D; 和&#x3D; 眼瞎了</p><p>改完后f2_Lcon没问题了。</p><p>修改y后25轮后没问题</p><p>修改z后25轮后没问题</p><p>但是hip版本修改后还是有问题。</p><p>接下来检查US和RK的一维版本有无问题。</p><p>US： OK</p><p>RK：OK</p><p>全部转为一维的了。</p><p>为什么hip还有错误。</p><p>去掉同步试试，没用</p><h4 id="一个核函数一个核函数试。"><a href="#一个核函数一个核函数试。" class="headerlink" title="一个核函数一个核函数试。"></a>一个核函数一个核函数试。</h4><p>从us开始</p><p>在hip_1的基础上hip_2上面改</p><p>想一下怎么改，cpu和dcu的函数不一样，要编译两个子函数。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project06</title>
    <link href="/2024/09/11/project06/"/>
    <url>/2024/09/11/project06/</url>
    
    <content type="html"><![CDATA[<h3 id="设置合适的threadsPerBlock-and-blocksPerGrid"><a href="#设置合适的threadsPerBlock-and-blocksPerGrid" class="headerlink" title="设置合适的threadsPerBlock and blocksPerGrid"></a>设置合适的threadsPerBlock and blocksPerGrid</h3><h4 id="dim3-blockPerGrid-256-256-256"><a href="#dim3-blockPerGrid-256-256-256" class="headerlink" title="dim3 blockPerGrid(256,256,256)"></a>dim3 blockPerGrid(256,256,256)</h4><p><img src="/../images/1726033156029.png" alt="1726033156029"></p><p><img src="/../images/1726033161793.png" alt="1726033161793"></p><p><img src="/../images/1726033167619.png" alt="1726033167619"></p><p><img src="/../images/1726033169640.png" alt="1726033169640"></p><h4 id="dim3-blockPerGrid-32-32-32"><a href="#dim3-blockPerGrid-32-32-32" class="headerlink" title="dim3 blockPerGrid(32,32,32)"></a>dim3 blockPerGrid(32,32,32)</h4><p>比数组下标大啊，为什么有错误。</p><p>256 也有错误？慢了，改什么了吗？</p><p>为什么之前没输出要打印的东西？</p><p>512？更慢</p><p>用256，5025 跑一个小时看看，不可能啊，什么都没动啊。</p><p>重新开个窗口跑。没用还是一样</p><p>blockPerGrid 50 设置同步，跑了两次的结果</p><p><img src="/../images/1726056863947.png" alt="1726056863947"></p><p><img src="/../images/1726056866342.png" alt="1726056866342"></p><p>blockPerGrid 50 设置同步，</p><p><img src="/../images/1726057060736.png" alt="1726057060736"></p><p>blockPerGrid 256  threadPerBlock 4设置同步 </p><p><img src="/../images/1726059275201.png" alt="1726059275201"></p><p>疑问？</p><p><img src="/../images/1726057910020.png" alt="1726057910020"></p><p>这里的k,j,i是从0开始取的吗，是连续的吗？</p><p>折磨的一天，不想写了。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java多线程01</title>
    <link href="/2024/09/10/java%E5%A4%9A%E7%BA%BF%E7%A8%8B01/"/>
    <url>/2024/09/10/java%E5%A4%9A%E7%BA%BF%E7%A8%8B01/</url>
    
    <content type="html"><![CDATA[<h2 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h2><h3 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h3><p><img src="/../images/1725959518876.png" alt="1725959518876"></p><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>主线程和子线程交替执行。</p><p><img src="/../images/1725959482658.png" alt="1725959482658"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-comment">//java thread</span><br><span class="hljs-comment">//当一个类继承了 Thread 类， 该类就可以当做线程使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//main函数里面就是一个主线程</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">//start,启动一个子线程，执行cat的run()方法.子线程和主线程交替执行</span><br>        cat.start();<br>        <span class="hljs-comment">// run方法就是一个方法，要等它执行完毕后才向下执行。</span><br>        <span class="hljs-comment">//cat.run();</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span> ; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程正在执行&quot;</span>+(++times)+ Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//每隔1s输出</span><br>            System.out.println(<span class="hljs-string">&quot;good day,&quot;</span>+(++times)+(Thread.currentThread().getName()));<br>            <span class="hljs-comment">//休眠1s</span><br>            <span class="hljs-comment">//ctrl alt t  输出异常</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(times == <span class="hljs-number">40</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>java是单继承的，如果一个类已经继承了一个类，就不能继承Thread类了。</p><p>可以通过实现Runnable接口来创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">//创建了 Thread 对象，把 dog 对象(实现 Runnable),放入 Thread</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(dog);<br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;小猫喵喵喵&quot;</span> + (++count) + Thread.currentThread().getName());<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多个子线程"><a href="#多个子线程" class="headerlink" title="多个子线程"></a>多个子线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hzb.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T1</span>();<br>        <span class="hljs-type">T2</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T2</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t2);<br>        <span class="hljs-comment">//也可以这样，多个线程共享一个资源</span><br>        <span class="hljs-comment">//Thread thread2 = new Thread(t1);</span><br>        thread1.start();<br>        thread2.start();<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>+(++count)+Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;bing&quot;</span>+(++count)+Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">20</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正常输出</p><p><img src="/../images/1725970723871.png" alt="1725970723871"></p><p>改为注释的代码后，输出，这就是多个线程共享同一个资源。</p><p><img src="/../images/1725970688762.png" alt="1725970688762"></p><p><img src="/../images/1725970756521.png" alt="1725970756521"></p><h3 id="实操（多线程模拟售票系统）"><a href="#实操（多线程模拟售票系统）" class="headerlink" title="实操（多线程模拟售票系统）"></a>实操（多线程模拟售票系统）</h3><p><img src="/../images/1725970793889.png" alt="1725970793889"></p><p>两种创建的方式都会出现超卖的现象。</p><p>出现这种现象的原因一个线程在休眠的时候，其他线程已经卖完了票，这个线程又卖了一个，出现超票。</p><p>后面会学到线程同步和互斥解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现接口的方式</span><br><span class="hljs-keyword">package</span> com.hzb.ticket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">sell</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">sellTicket</span> <span class="hljs-variable">sellTicket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">sellTicket</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket);<br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sellTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//输出放在这里不会出现超票的情况，放在下面会发生。</span><br>            System.out.println(<span class="hljs-string">&quot;售票员&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了一张票，剩余的票数为&quot;</span> + (--count));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//System.out.println(&quot;售票员&quot; + Thread.currentThread().getName() + &quot;卖出了一张票，剩余的票数为&quot; + (--count));</span><br><br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>高性能，开发算法，都可以作为毕业工作的方向。都了解也没坏处。所以说我做的东西还是有用的。</p><p>加油少年。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project05</title>
    <link href="/2024/09/09/project05/"/>
    <url>/2024/09/09/project05/</url>
    
    <content type="html"><![CDATA[<h3 id="find-the-error"><a href="#find-the-error" class="headerlink" title="find the error"></a>find the error</h3><p>程序运行慢的原因：申请的block数太多了，可能线程等待什么的需要时间。</p><p>改完后要比c快很多。</p><p>计算误差</p><p>225轮测试基本没有误差。</p><p><img src="/../images/1725885874956.png" alt="1725885874956"></p><p>时间：225 轮</p><p>hip : 16min      f 走了94轮</p><p>快一倍不止</p><p>时间：5025轮</p><p>差不多三倍</p><h3 id="前期优化已经完成，后期优化方向"><a href="#前期优化已经完成，后期优化方向" class="headerlink" title="前期优化已经完成，后期优化方向"></a>前期优化已经完成，后期优化方向</h3><p>设置合适的block和thread</p><p>合并内存访问</p><p>bank冲突</p><p>shared memory</p><p>寄存器</p><p>多dcu</p><p>多节点</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project04</title>
    <link href="/2024/09/08/project04/"/>
    <url>/2024/09/08/project04/</url>
    
    <content type="html"><![CDATA[<p>找到了，真的不好发现吧。</p><p><img src="/../images/1725778438293.png" alt="1725778438293"></p><p>Flux_xyz_FVM这里是<code>FLuidtwo </code>，为什么我写了两个<code>FLuidone</code></p><p>在验证一下US和RK，都没问题了，就再写成hip，然后再将两个equation写成一个，减少数据传输。有些值不用传回来。</p><p>US没问题</p><p>RK没问题</p><p>跑一步要十五分钟？</p><p>更改的数组有哪些？</p><p>Flux_FVM_US：<br>den 等数组赋值给flux_US</p><p>Flux_xyz:<br>den 等数组和flux_US赋值给flux<br>flux赋值给Lcon</p><p>Euler_equ_RK:<br>flux_US等数组赋值给con</p><p>只有这几个</p><p>flux_US，flux，Lcon，con</p><p>所以说其他的数组和值没变，不用传回来。</p><p>全部传回来：15min</p><p>只传改过的数组：快一点，没快多少。说明传输占用的时间不多。</p><p>两个eqation是eq2文件中的代码</p><p>改为一个equation，写成3D_Cut-Cell_hip_p</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project03</title>
    <link href="/2024/09/07/project03/"/>
    <url>/2024/09/07/project03/</url>
    
    <content type="html"><![CDATA[<p>对比两个代码<code>Flux_x_FVM1.c    Flux_x_FVM.c</code>没有发现任何问题。</p><p>计算机内部发生了什么。</p><p><img src="/../images/1725601244759.png" alt="1725601244759"></p><p>对应c，k,j,i  &#x3D; 27 ,22 ,27</p><p>根据下标找不太现实。</p><p>在指定的位置输出，比较两个文件的数据，每一行一个数据，检查偏移量是不是计算有错误。</p><p>只改x和y，输出的内容是一样的，说明这个错误在两个函数里面都有。</p><p>输出了x里面fluid &#x3D; 1 的值，没有问题。</p><p>输出下 fluid &#x3D; 2;</p><p>在特定的地方输出了一些数据，和原始数组作对比</p><p>do istep</p><p>do RK</p><p>RK &#x3D; 1</p><p>flux  Y</p><p>fluid 1 flux1 </p><p>fluid 1 flux2 </p><p>fluid 1 Lcon </p><p>flux  Y</p><p>Y fluid 2 flux1</p><p>fluid 2 flux2</p><p>fluid 2 Lcon </p><p>RK  &#x3D;2 </p><p>flux </p><p>fluid 1 flux1  Y</p><p>fluid 1 flux2 Y</p><p>fluid 1 Lcon  Y</p><p>dL算完是对</p><p>Y flux N 这里，前后不一致，只能是其他的参数传入错误，或者函数本身有错误（函数本身没变，几率小）</p><p>N fluid 2 flux1</p><p>fluid 2 flux2</p><p>Y fluid 2 Lcon N</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project02</title>
    <link href="/2024/09/05/project02/"/>
    <url>/2024/09/05/project02/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/1725510566478.png" alt="1725510566478"></p><p>invflux函数不是US特有的，把US转成hip的时候，子函数怎么处理呢？因为其他函数还要用。</p><p>编译两个函数，cpu and dcu. invflux.o  and invflux1.o</p><p><img src="/../images/1725518462734.png" alt="1725518462734"></p><p>这个问题是，传入的是数组的指针，而函数原型期望的是一个具体的数组，具有明确的维度。这种情况下，C++ 编译器会抱怨类型不匹配，因为指针和数组并不完全等价，特别是当数组是多维数组时。</p><p>这个应该是c++的问题。.c 没有问题。</p><p>但是如果不把equation改成.cpp，就不能用hip</p><p>挺麻烦的。</p><p>把所有的数组都改成一维的吧。不然太容易出事了。</p><p>步骤：</p><p>不考虑hip，逐个函数改成一维数组。改完验证。</p><p><img src="/../images/1725528962350.png" alt="1725528962350"></p><p>把Flux_FVM_xyz 转为一维后error</p><p>找到具体的函数。</p><p>先把xyz全加上，都用之前的。</p><p>感觉还是多维数组转一维的时候计算出了问题，偏移量？for循环？</p><p>只改Flux_FVM_x，</p><p><img src="/../images/1725539404148.png" alt="1725539404148"></p><p>说明是Flux_FVM_x里面的问题。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project01</title>
    <link href="/2024/09/04/project01/"/>
    <url>/2024/09/04/project01/</url>
    
    <content type="html"><![CDATA[<p>把所有的全局变量通过参数的形式传入函数。</p><p><img src="/../images/1725455051738.png" alt="1725455051738"></p><p>这些值，改完后运行没有问题。</p><p>后面试一下混编，c和c++一起，生成一个动态链接库。</p><p>c不行的话，后缀都改成cpp</p><p>先在<code>euler_equation_fvm_c_</code>里面加上extern “C”，混编要注意编译选项的问题。</p><p>一个函数一个函数测试，先从US开始。</p><p>找到具体的dcu bug在哪个地方。</p><p>tip： 研究生能不能取消导师制度，学生不是老师压榨的工具。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《幻夜》</title>
    <link href="/2024/09/04/%E5%B9%BB%E5%A4%9C/"/>
    <url>/2024/09/04/%E5%B9%BB%E5%A4%9C/</url>
    
    <content type="html"><![CDATA[<p>我们不是说好了吗，两个人要斗争到底。周围全是敌人。我们为了生存下去，无法干高尚的事。</p><p>为什么背叛，为什么杀死我的灵魂，你说我们没有白昼，任何时候都是黑夜，说过我们要在黑夜中生存下去。</p><p>即便如此，我也无所谓，只要是真正的黑夜就行。然而，你连那个都没有给我，你给予我的全是虚幻。</p><p><img src="/../images/1725423808559.png" alt="1725423808559"></p><p>看这本书的时候，越看越像东野圭吾老师的另一本书《白夜行》。雅也从杀死舅舅的那一刻就走上了一条不归路，爱上了美冬，在黑夜中帮助他。”像我们这样的人，为了我们的未来我们，我们必须这么做“，雅也想起美冬的话，他不能回头了。美冬说的未来究竟是什么，他也不知道，有一件事他是明白的，他们不可能过上和正常人一样的生活了，只能在黑暗中一直前行。</p><blockquote><p><strong>“即使四周明亮有如白昼，那也只是假象”</strong><br><strong>“就算与你共度的每个夜晚都是假象，我也愿为你化身为影，至死不渝。”</strong></p></blockquote><p><strong>是雅也对美冬的告白。</strong></p><p>她是个贪婪的人，无情地想要得到身边的一切，不惜任何代价。没有道德，没有下线，没有感情，她甚至都忘记了什么是爱。</p><p>他救过她，为她付出了生命中的一切。甚至在知道被她背叛后，知道自己只是她的一个工具的时候。直到生命的最后一刻，他还在保护着她。</p><p>文章的最后。“这么美好的夜晚还是第一次看到，简直像幻夜一般。”说着，她露出妖媚的笑容。</p><p>《白夜行》的最后，桐原亮司的死带走了她最后一丝光，白夜已经消逝。<br>《幻夜》的最后，水原雅也的死点缀了她的世界，幻夜才刚刚开始。</p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project process 2</title>
    <link href="/2024/08/25/project_process2/"/>
    <url>/2024/08/25/project_process2/</url>
    
    <content type="html"><![CDATA[<p>srun -N 1 –mem&#x3D;16G .&#x2F;3D</p><p>输出.plt文件有错误</p><p><img src="/../images/1722410248434.png" alt="1722410248434">open(unit&#x3D;ifile,file&#x3D;’.&#x2F;result&#x2F;spec’&#x2F;&#x2F;filename&#x2F;&#x2F;‘.plt’,status&#x3D;’unknown’,form&#x3D;”BINARY”)</p><p>vtune要显示源文件的每一行占用的时间，编译的时候加上-g编译选项。</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/1722498047341.png" alt="1722498047341"></h5><p><img src="/../images/1722498061895.png" alt="1722498061895"></p><p>一个函数一个函数验证</p><hr><p>2024年8月25日21:31:09</p><p><img src="/../images/1724592704176.png" alt="1724592704176"></p><p>Flux_FVM_US 里面这里输出的k,j,i没有错误，和源fortran代码对的上。说明这个数组下标对应正确，再排查一遍所有的数组下标变换。</p><p>2024年8月26日12:56:27</p><p>把其他注释掉，只剩一个US，结果一样。</p><p>同理</p><p>将RK注释，其他不变，结果一样</p><p>取消RK注释，输出结果dcu的有错误，问题很有可能在RK中。</p><p>RK中没找到错误，。。。</p><p>注释掉main函数中Euler_equation_FVM后面的所有代码，得到的结果是一样的。</p><p>数据传过来的时候出现了错误？</p><p>先验证最后算对了没，如果结果一样，就是传输出现了问题。</p><p>结果一致。con2的值是被改过的，改过的值两个代码相同。</p><p>说明计算部分的代码没问题。</p><p>传输回来的值和计算的值一样，RK&#x3D;1和RK&#x3D;2都是一样。</p><p>问题在哪，为什么会中断。</p><p><img src="/../images/1724676676172.png" alt="1724676676172"></p><p>这里错了，将错误的数传给ct_fluxsolver了，正常情况下这个值没被改变，注释掉就行。</p><p>改了，还是有错误，相同的错误。？？？</p><p>发生这个错误和在main函数中把Euler_equaion_FVM注释掉得到的错误一样，说明有值没有经过计算更新后传回来。</p><p>flux Lcon等数组要传回来，否则是初始值，因为他们的值在Fluid&#x3D;1的时候被改了，然而在Fluid &#x3D; 2 的时候又要用到。</p><p>可能还有其他的数组。</p><p>最后实在不行，就传输两次。因为中间可能改了很多数组。不止是这三个数组！！！</p><p>2024年8月27日14:48:03</p><p>分开写，还是以前在main函数中调用equation的方法。easy</p><p>分开写也是同样的错误。。。</p><p>把flux Lcon等数组的初始赋值放到Fluid&#x3D;1的分支中，然后结果还是一样。</p><p>不是这的问题。</p><p>从错误的地方找</p><p><img src="/../images/1724747253700.png" alt="1724747253700"></p><p>在interface_invflux中</p><p><img src="/../images/1724747283463.png" alt="1724747283463"></p><p>在all_con_2_prim中</p><p><img src="/../images/1724747321323.png" alt="1724747321323"></p><p>输出了</p><p><img src="/../images/1724747351639.png" alt="1724747351639"></p><p>结果不同</p><p>c:</p><p><img src="/../images/1724751501864.png" alt="1724751501864"></p><p>f:</p><p><img src="/../images/1724747385943.png" alt="1724747385943"></p><p>结果显而易见，den和con的值算错了，导致vel_u等值发生NAN，程序中断。den &#x3D; Nan ，导致Nan</p><p>在RK中输出con的值</p><p><img src="/../images/1724751530756.png" alt="1724751530756"></p><p><img src="/../images/1724751556911.png" alt="1724751556911"></p><p>找这个下标对应的值更改的地方。</p><p>经过对比，RK里面imark&#x3D;0时，RK&#x3D;1时，con的前后输出不同。错误就在这之间的代码中。</p><p>输出s,f的值，看是否相同，相同。</p><p>注释的这一块有错误</p><p><img src="/../images/1724762317651.png" alt="1724762317651"></p><p>值是由con[0]赋值过来的，所以输出一下con[0]</p><p><img src="/../images/1724762383136.png" alt="1724762383136"></p><p><img src="/../images/1724762433960.png" alt="1724762433960"></p><p>结果。。。也没问题，全是0</p><p>只能是delta_t的问题了。</p><p>输出为都是0，也不是。。。</p><p>只能是下标对应错误了。index5D_0，index5D_1的计算有错误吗。</p><p>2024年8月28日14:40:51</p><p><img src="/../images/1724828853047.png" alt="1724828853047"></p><p><img src="/../images/1724828858239.png" alt="1724828858239"></p><p>输出这一个看一下</p><p>f:m&#x3D;1,</p><p>c:m&#x3D;0</p><p><img src="/../images/1724831910112.png" alt="1724831910112"></p><p>得到结果<img src="/../images/1724831921342.png" alt="1724831921342"></p><p>所以还是s,f的值有问题。</p><p>然后分段看，到底哪个部分是nan</p><p>f,s 应该在外面定义。并不是一个线程定义一个f和s（不好说，我又改过来了，2024年9月1日14:56:39）</p><p>写成dcu4</p><p>能跑了，运行的时候很慢，RK&#x3D;1和RK&#x3D;2两种情况，数组fs等数组的输入输出，要来回传吗，还是。。。</p><p>什么导致的这么慢？。。</p><p><img src="/../images/1724847879746.png" alt="1724847879746"></p><p>停住很久。</p><p>2024年8月30日14:33:58</p><p>为什么输出循序不对。。。缓冲区。。。</p><p>跑两步，有错误。。。</p><p>2024年8月31日21:30:12</p><p>不行就写两个函数，先试试。</p><p>因为1和2 的要初始化的数组不一样。。</p><p>数组啊啊啊啊啊啊。。。。加油</p><p>就盯着那几个数组。。。其他应该没问题。</p><p>2024年9月1日20:25:07</p><p>hipprof 表示RK占用的时间最多，应该是这个的问题，数组占用时间太多了，<br>处理完这个问题，然后再解决程序bug</p><p>2024年9月2日14:37:28</p><p>可以一个核函数一个函数验证。RK可以用之前的RK，其他的函数用核函数。</p><p>或者直接在之前的程序上面改。</p><p>11850148.log  对应dcu5，全部核函数，巨慢，一步10min more </p><p>把RK换成之前的函数。所有值，在RK之前传过来。</p><p>一点一点改吧。。</p><p>2024年9月4日13:03:44</p><p>在3D_Cut-Cell_hip_1一点一点添加dcu的内容。</p><p>从改好的c程序开始</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目c转hip</title>
    <link href="/2024/07/14/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    <url>/2024/07/14/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>head_hip目录中.h文件<br>1.声明核函数（__global__函数）和__device__函数和c函数<br>实现在具体的.cpp代码中<br>2.声明全局参数</p><p>src_hip目录中.cpp文件<br>1.导入声明核函数和c函数的.h头文件。<br>2.实现核函数。调用__device__函数。__device__函数在本代码实现，用于核函数中调用。<br>3.实现c函数。调用本代码的核函数或者其他地方实现的核函数。</p><p>整体思路就是把数据初始化和计算的部分用核函数实现，其他的地方保持不变。把__device__函数和__global__函数在.h文件声明，然后在具体的.cpp文件中实现。<br>我的想法就是先在Equation里面把用到的数据传到gpu，然后Equation调用的那五个函数。每个函数里面都有三重for循环。每次循环之间都是独立的。把这三重for循环写成一个核函数，每个线程处理其中的几个循环。其中调用的子函数写成__device__函数。<br>还有就是c转为hip，数组要展开成一维的，设置下标索引对应。<br>结构图我画不出来，就是主函数调用其他函数，然后继续调用，把初始化和计算的部分写成核函数。<br>两个Equation外面加一个父函数，在父函数中进行数据传输，这样只用传输一次数据。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><h4 id="什么时候传入？"><a href="#什么时候传入？" class="headerlink" title="什么时候传入？"></a>什么时候传入？</h4><p>有两个Equation，数据传输不要写在Equation里面，因为有两个Equation，这样就要数据传输两次，在Equation调用之前进行数据传输。因为整个过程是封装在动态链接库中，所以要在给Equation加一个父函数，父函数调用Equation，在父函数中进行数据传输，父函数为动态链接库的主函数。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="1-先写出这个父函数。定义：PEquation"><a href="#1-先写出这个父函数。定义：PEquation" class="headerlink" title="1.先写出这个父函数。定义：PEquation"></a>1.先写出这个父函数。定义：PEquation</h4><p>3D_Cut-Cell_hip</p><h4 id="2-在父函数中将数据传入GPU"><a href="#2-在父函数中将数据传入GPU" class="headerlink" title="2.在父函数中将数据传入GPU"></a>2.在父函数中将数据传入GPU</h4><p>传入哪些数据？</p><p>参与计算的数据</p><h4 id="数组的下标怎么对应"><a href="#数组的下标怎么对应" class="headerlink" title="数组的下标怎么对应"></a>数组的下标怎么对应</h4><p>CPU传入GPU，直接传，但是传入的数组是一维的。在device或global函数中用到该数组的时候，在一维数组利用索引对应到操作到多维数组的下标。</p><p>threadPerBlock 最大256</p><p>一个线程处理for循环的一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime_api.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W 3</span><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">processKernel</span><span class="hljs-params">(<span class="hljs-type">int</span>* imark, <span class="hljs-type">int</span>* cut_model, <span class="hljs-type">float</span>* xyzside, <span class="hljs-type">int</span> nx, <span class="hljs-type">int</span> ny, <span class="hljs-type">int</span> nz, <span class="hljs-type">int</span> w, </span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span> inter_iL, <span class="hljs-type">int</span> inter_iR, <span class="hljs-type">int</span> inter_jL, <span class="hljs-type">int</span> inter_jR, <span class="hljs-type">int</span> inter_kL, <span class="hljs-type">int</span> inter_kR,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span>* counter)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = blockIdx.z * blockDim.z + threadIdx.z;<br>    <span class="hljs-type">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;<br><br>    <span class="hljs-keyword">if</span> (k &gt;= inter_kL &amp;&amp; k &lt;= inter_kR &amp;&amp;<br>        j &gt;= inter_jL &amp;&amp; j &lt;= inter_jR &amp;&amp;<br>        i &gt;= inter_iL &amp;&amp; i &lt;= inter_iR) &#123;<br><br>        <span class="hljs-type">int</span> index3D = k * (ny * nx) + j * nx + i;<br>        imark[index3D] += cut_model[index3D];<br>        <br>        <br>        <span class="hljs-type">int</span> index4D = k * (ny * nx * w) + j * (nx * w) + i * w;<br>        <span class="hljs-comment">//操作4维数组</span><br>        xyzside[index4D + <span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        xyzside[index4D + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        xyzside[index4D + <span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><br><br>       <br><br>        <span class="hljs-comment">// 更新计数器</span><br>        <span class="hljs-built_in">atomicAdd</span>(counter, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义数组大小</span><br>    <span class="hljs-type">int</span> nx = NX, ny = NY, nz = NZ, w = W;<br>    <span class="hljs-type">int</span> arraySize3D = nx * ny * nz;<br>    <span class="hljs-type">int</span> arraySize4D = nx * ny * nz * w;<br><br>    <span class="hljs-comment">// 分配并初始化CPU上的数组</span><br>    <span class="hljs-type">int</span>* h_imark = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">int</span>* h_cut_model = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">float</span>* h_xyzside = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[arraySize4D];<br><br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        h_imark[i] = <span class="hljs-number">0</span>;<br>        h_cut_model[i] = <span class="hljs-number">-99</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize4D; i++) &#123;<br>        h_xyzside[i] = <span class="hljs-number">0.0f</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配GPU内存</span><br>    <span class="hljs-type">int</span>* d_imark;<br>    <span class="hljs-type">int</span>* d_cut_model;<br>    <span class="hljs-type">float</span>* d_xyzside;<br>    <span class="hljs-type">int</span>* d_counter;<br>    <span class="hljs-type">int</span> h_counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">// 将数据从CPU传输到GPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(d_imark, h_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_cut_model, h_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_xyzside, h_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_counter, &amp;h_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// 定义线程块和网格的大小</span><br>    <span class="hljs-comment">//一个block最大线程256</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">threadsPerBlock</span><span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-comment">//根据问题的规模确定定义几个线程块</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">blocksPerGrid</span><span class="hljs-params">((nx + threadsPerBlock.x - <span class="hljs-number">1</span>) / threadsPerBlock.x,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (ny + threadsPerBlock.y - <span class="hljs-number">1</span>) / threadsPerBlock.y,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (nz + threadsPerBlock.z - <span class="hljs-number">1</span>) / threadsPerBlock.z)</span></span>;<br><br>    <span class="hljs-comment">// 调用CUDA内核函数</span><br>    <span class="hljs-type">int</span> inter_iL = <span class="hljs-number">0</span>, inter_iR = nx - <span class="hljs-number">1</span>, inter_jL = <span class="hljs-number">0</span>, inter_jR = ny - <span class="hljs-number">1</span>, inter_kL = <span class="hljs-number">0</span>, inter_kR = nz - <span class="hljs-number">1</span>;<br>    processKernel&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_imark, d_cut_model, d_xyzside, nx, ny, nz, w, <br>                                                      inter_iL, inter_iR, inter_jL, inter_jR, inter_kL, inter_kR, d_counter);<br><br>    <span class="hljs-comment">// 等待GPU完成</span><br>    <span class="hljs-built_in">hipDeviceSynchronize</span>();<br><br>    <span class="hljs-comment">// 将结果从GPU传回CPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(h_imark, d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_cut_model, d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_xyzside, d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(&amp;h_counter, d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// 检查计数器</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total elements processed: &quot;</span> &lt;&lt; h_counter &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 打印结果（如果需要）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        std::cout &lt;&lt; h_imark[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize4D; i++) &#123;<br>        std::cout &lt;&lt; h_xyzside[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放GPU内存</span><br>    <span class="hljs-built_in">hipFree</span>(d_imark);<br>    <span class="hljs-built_in">hipFree</span>(d_cut_model);<br>    <span class="hljs-built_in">hipFree</span>(d_xyzside);<br>    <span class="hljs-built_in">hipFree</span>(d_counter);<br><br>    <span class="hljs-comment">// 释放CPU内存</span><br>    <span class="hljs-keyword">delete</span>[] h_imark;<br>    <span class="hljs-keyword">delete</span>[] h_cut_model;<br>    <span class="hljs-keyword">delete</span>[] h_xyzside;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="子函数写成device形式，通过参数传入线程号。"><a href="#子函数写成device形式，通过参数传入线程号。" class="headerlink" title="子函数写成device形式，通过参数传入线程号。"></a>子函数写成device形式，通过参数传入线程号。</h4><p>可能不需要传入线程号，把要操作的数组传入即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime_api.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W 3</span><br><span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">fun_dev1</span><span class="hljs-params">(<span class="hljs-type">int</span>* dL,<span class="hljs-type">int</span> xyzside)</span></span>&#123;<br>    *dL = xyzside;<br>&#125;<br><span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">fun_dev2</span><span class="hljs-params">(<span class="hljs-type">int</span> dL,<span class="hljs-type">int</span>* array1)</span></span>&#123;<br>    *array1 = dL;<br><br>&#125;<br><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">processKernel</span><span class="hljs-params">(<span class="hljs-type">int</span>* imark, <span class="hljs-type">int</span>* cut_model, <span class="hljs-type">int</span>* xyzside,<span class="hljs-type">int</span>* array1D,<span class="hljs-type">int</span>* array2D,<span class="hljs-type">int</span>* array1,<span class="hljs-type">int</span> nx, <span class="hljs-type">int</span> ny, <span class="hljs-type">int</span> nz, <span class="hljs-type">int</span> w, </span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span> inter_iL, <span class="hljs-type">int</span> inter_iR, <span class="hljs-type">int</span> inter_jL, <span class="hljs-type">int</span> inter_jR, <span class="hljs-type">int</span> inter_kL, <span class="hljs-type">int</span> inter_kR,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span>* counter)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = blockIdx.z * blockDim.z + threadIdx.z;<br>    <span class="hljs-type">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;<br>    <br>    <span class="hljs-type">int</span> dL;<br>    <br>    <br>    <span class="hljs-comment">//三维数组的范围[nz][ny][nx],nz = inter_kR...,保证不越界</span><br>    <span class="hljs-keyword">if</span> (k &gt;= inter_kL &amp;&amp; k &lt;= inter_kR &amp;&amp;<br>        j &gt;= inter_jL &amp;&amp; j &lt;= inter_jR &amp;&amp;<br>        i &gt;= inter_iL &amp;&amp; i &lt;= inter_iR) &#123;<br><br>        <span class="hljs-type">int</span> index3D = k * (ny * nx) + j * nx + i;<br>        imark[index3D] += cut_model[index3D];<br>        <span class="hljs-type">int</span> index4D = k * (ny * nx * w) + j * (nx * w) + i * w;<br>        xyzside[index4D + <span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        xyzside[index4D + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        xyzside[index4D + <span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">//调用device函数,将xyzside[k][j][i][0]的值赋给dL</span><br>        <span class="hljs-built_in">fun_dev1</span>(&amp;dL,xyzside[index4D + <span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//调用device函数，再将dL的值传给一维数组,no ploblem</span><br>        <span class="hljs-built_in">fun_dev2</span>(dL,array1[index3D]);<br><br><br>        <br>        <span class="hljs-comment">// 更新计数器</span><br>        <span class="hljs-built_in">atomicAdd</span>(counter, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义数组大小</span><br>    <span class="hljs-type">int</span> nx = NX, ny = NY, nz = NZ, w = W;<br>    <span class="hljs-type">int</span> arraySize3D = nx * ny * nz;<br>    <span class="hljs-type">int</span> arraySize4D = nx * ny * nz * w;<br>    <span class="hljs-type">int</span> arraySize2D = nx * ny;<br>    <span class="hljs-type">int</span> arraySize1D = nx;<br>    <br><br>    <span class="hljs-comment">// 分配并初始化CPU上的数组</span><br>    <span class="hljs-type">int</span>* h_imark = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">int</span>* h_cut_model = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">int</span>* h_xyzside = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize4D];<br>    <span class="hljs-type">int</span>* h_array2D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize2D];<br>    <span class="hljs-type">int</span>* h_array1D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize1D];<br>    <span class="hljs-type">int</span>* h_array1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br><br><br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        h_imark[i] = <span class="hljs-number">0</span>;<br>        h_cut_model[i] = <span class="hljs-number">-99</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize4D; i++) &#123;<br>        h_xyzside[i] = <span class="hljs-number">0.0f</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize2D;i++)&#123;<br>        h_array2D[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize1D;i++)&#123;<br>        h_array1D[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize3D;i++)&#123;<br>        h_array1[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br><br><br>    <span class="hljs-comment">// 分配GPU内存</span><br>    <span class="hljs-type">int</span>* d_imark;<br>    <span class="hljs-type">int</span>* d_cut_model;<br>    <span class="hljs-type">int</span>* d_xyzside;<br>    <span class="hljs-type">int</span>* d_counter;<br>    <span class="hljs-type">int</span>* d_array2D;<br>    <span class="hljs-type">int</span>* d_array1D;<br>    <span class="hljs-type">int</span>* d_array1;<br>    <span class="hljs-type">int</span> h_counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array1D,arraySize1D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br><br>    <span class="hljs-comment">// 将数据从CPU传输到GPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(d_imark, h_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_cut_model, h_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_xyzside, h_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array2D,h_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array1D,h_array1D,arraySize1D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array1,h_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_counter, &amp;h_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// 定义线程块和网格的大小</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">threadsPerBlock</span><span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">blocksPerGrid</span><span class="hljs-params">((nx + threadsPerBlock.x - <span class="hljs-number">1</span>) / threadsPerBlock.x,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (ny + threadsPerBlock.y - <span class="hljs-number">1</span>) / threadsPerBlock.y,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (nz + threadsPerBlock.z - <span class="hljs-number">1</span>) / threadsPerBlock.z)</span></span>;<br><br>    <span class="hljs-comment">// 调用CUDA内核函数</span><br>    <span class="hljs-type">int</span> inter_iL = <span class="hljs-number">0</span>, inter_iR = nx - <span class="hljs-number">1</span>, inter_jL = <span class="hljs-number">0</span>, inter_jR = ny - <span class="hljs-number">1</span>, inter_kL = <span class="hljs-number">0</span>, inter_kR = nz - <span class="hljs-number">1</span>;<br>    processKernel&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_imark, d_cut_model, d_xyzside,d_array1D,d_array2D, d_array1,nx, ny, nz, w, <br>                                                      inter_iL, inter_iR, inter_jL, inter_jR, inter_kL, inter_kR, d_counter);<br><br>    <span class="hljs-comment">// 等待GPU完成</span><br>    <span class="hljs-built_in">hipDeviceSynchronize</span>();<br><br>    <span class="hljs-comment">// 将结果从GPU传回CPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(h_imark, d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_cut_model, d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_xyzside, d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array2D,d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array2D,d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array1,d_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(&amp;h_counter, d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// 检查计数器</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total elements processed: &quot;</span> &lt;&lt; h_counter &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 打印结果（如果需要）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        std::cout &lt;&lt; h_imark[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize4D; i++) &#123;<br>        std::cout &lt;&lt; h_xyzside[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt; arraySize2D;i++)&#123;<br>        std::cout &lt;&lt; h_array2D[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt; arraySize1D;i++)&#123;<br>        std::cout &lt;&lt; h_array1D[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        std::cout &lt;&lt; h_array1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br><br>    <span class="hljs-comment">// 释放GPU内存</span><br>    <span class="hljs-built_in">hipFree</span>(d_imark);<br>    <span class="hljs-built_in">hipFree</span>(d_cut_model);<br>    <span class="hljs-built_in">hipFree</span>(d_xyzside);<br>    <span class="hljs-built_in">hipFree</span>(d_array2D);<br>    <span class="hljs-built_in">hipFree</span>(d_array1D);<br>    <span class="hljs-built_in">hipFree</span>(d_counter);<br><br>    <span class="hljs-comment">// 释放CPU内存</span><br>    <span class="hljs-keyword">delete</span>[] h_imark;<br>    <span class="hljs-keyword">delete</span>[] h_cut_model;<br>    <span class="hljs-keyword">delete</span>[] h_xyzside;<br>    <span class="hljs-keyword">delete</span>[] h_array1D;<br>    <span class="hljs-keyword">delete</span>[] h_array2D;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h3><p>把后缀改成.c++，c++函数调用，参数不匹配的问题。可能是需要导入定义函数的头文件。c++里面</p><p>下标对应问题，问题规模，for循环的参数.</p><p>ijk不是对应的数组的下标，而是对应三重for循环，每一次for循环对应一次数组下标。再做相应操作</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>第三维度是nz</p><p><img src="/../images/1721198547896.png" alt="1721198547896"></p><p>k,对应第三维，即<strong>k对应nz</strong></p><p><img src="/../images/1721198572456.png" alt="1721198572456"></p><p>数组大小为<code>[nz][ny][nx]</code>,所以对应<code>[k][j][i]</code>,对应正确</p><p><img src="/../images/1721198641452.png" alt="1721198641452"></p><p>nz ny nx 是数组的大小 </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime_api.h&gt;</span></span><br><span class="hljs-comment">//每层for循环的大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NZ 15</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NY 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NX 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W 3</span><br><span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">fun_dev1</span><span class="hljs-params">(<span class="hljs-type">int</span>* dL,<span class="hljs-type">int</span> xyzside)</span></span>&#123;<br>    *dL = xyzside;<br>&#125;<br><span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">fun_dev2</span><span class="hljs-params">(<span class="hljs-type">int</span> dL,<span class="hljs-type">int</span>* array1)</span></span>&#123;<br>    *array1 = dL;<br><br>&#125;<br><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">processKernel</span><span class="hljs-params">(<span class="hljs-type">int</span>* imark, <span class="hljs-type">int</span>* cut_model, <span class="hljs-type">int</span>* xyzside,<span class="hljs-type">int</span>* array1D,<span class="hljs-type">int</span>* array2D,<span class="hljs-type">int</span>* array1,<span class="hljs-type">int</span> nx, <span class="hljs-type">int</span> ny, <span class="hljs-type">int</span> nz, <span class="hljs-type">int</span> w, </span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span> inter_iL, <span class="hljs-type">int</span> inter_iR, <span class="hljs-type">int</span> inter_jL, <span class="hljs-type">int</span> inter_jR, <span class="hljs-type">int</span> inter_kL, <span class="hljs-type">int</span> inter_kR,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int</span>* counter)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = blockIdx.z * blockDim.z + threadIdx.z;<br>    <span class="hljs-type">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;<br>    <span class="hljs-type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;<br>    <br>    <span class="hljs-type">int</span> dL;<br>    <br>    <br>    <span class="hljs-comment">//三维数组的范围[nz][ny][nx],nz = inter_kR...,保证不越界</span><br>    <span class="hljs-keyword">if</span> (k &gt;= inter_kL &amp;&amp; k &lt;= inter_kR &amp;&amp;<br>        j &gt;= inter_jL &amp;&amp; j &lt;= inter_jR &amp;&amp;<br>        i &gt;= inter_iL &amp;&amp; i &lt;= inter_iR) &#123;<br><br>        <span class="hljs-type">int</span> index3D = k * (ny * nx) + j * nx + i;<br>        imark[index3D] += cut_model[index3D];<br>        <span class="hljs-type">int</span> index4D = k * (ny * nx * w) + j * (nx * w) + i * w;<br>        xyzside[index4D + <span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        xyzside[index4D + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        xyzside[index4D + <span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">//调用device函数,将xyzside[k][j][i][0]的值赋给dL</span><br>        <span class="hljs-comment">//fun_dev1(&amp;dL,xyzside[index4D + 0]);</span><br>        <span class="hljs-comment">//调用device函数，再将dL的值传给一维数组</span><br>        <span class="hljs-comment">//fun_dev2(dL,&amp;array1[index3D]);</span><br><br><br>        <br>        <span class="hljs-comment">// 更新计数器</span><br>        <span class="hljs-built_in">atomicAdd</span>(counter, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义数组大小</span><br>    <span class="hljs-type">int</span> nx = NX+<span class="hljs-number">4</span>, ny = NY+<span class="hljs-number">4</span>, nz = NZ+<span class="hljs-number">4</span>, w = W;<br>    <span class="hljs-type">int</span> arraySize3D = nx * ny * nz;<br>    <span class="hljs-type">int</span> arraySize4D = nx * ny * nz * w;<br>    <span class="hljs-type">int</span> arraySize2D = nx * ny;<br>    <span class="hljs-type">int</span> arraySize1D = nx;<br>    <br><br>    <span class="hljs-comment">// 分配并初始化CPU上的数组</span><br>    <span class="hljs-type">int</span>* h_imark = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">int</span>* h_cut_model = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br>    <span class="hljs-type">int</span>* h_xyzside = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize4D];<br>    <span class="hljs-type">int</span>* h_array2D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize2D];<br>    <span class="hljs-type">int</span>* h_array1D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize1D];<br>    <span class="hljs-type">int</span>* h_array1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize3D];<br><br><br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize3D; i++) &#123;<br>        h_imark[i] = <span class="hljs-number">0</span>;<br>        h_cut_model[i] = <span class="hljs-number">-99</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize4D; i++) &#123;<br>        h_xyzside[i] = <span class="hljs-number">0.0f</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize2D;i++)&#123;<br>        h_array2D[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize1D;i++)&#123;<br>        h_array1D[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;arraySize3D;i++)&#123;<br>        h_array1[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br><br><br>    <span class="hljs-comment">// 分配GPU内存</span><br>    <span class="hljs-type">int</span>* d_imark;<br>    <span class="hljs-type">int</span>* d_cut_model;<br>    <span class="hljs-type">int</span>* d_xyzside;<br>    <span class="hljs-type">int</span>* d_counter;<br>    <span class="hljs-type">int</span>* d_array2D;<br>    <span class="hljs-type">int</span>* d_array1D;<br>    <span class="hljs-type">int</span>* d_array1;<br>    <span class="hljs-type">int</span> h_counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array1D,arraySize1D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">hipMalloc</span>(&amp;d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br><br>    <span class="hljs-comment">// 将数据从CPU传输到GPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(d_imark, h_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_cut_model, h_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_xyzside, h_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array2D,h_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array1D,h_array1D,arraySize1D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_array1,h_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>    <span class="hljs-built_in">hipMemcpy</span>(d_counter, &amp;h_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyHostToDevice);<br><br>    <span class="hljs-comment">// 定义线程块和网格的大小</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">threadsPerBlock</span><span class="hljs-params">(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-comment">//nx ny nz 数组的大小[nz][ny][nx]</span><br>    <span class="hljs-function">dim3 <span class="hljs-title">blocksPerGrid</span><span class="hljs-params">((nx + threadsPerBlock.x - <span class="hljs-number">1</span>) / threadsPerBlock.x,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (ny + threadsPerBlock.y - <span class="hljs-number">1</span>) / threadsPerBlock.y,</span></span><br><span class="hljs-params"><span class="hljs-function">                       (nz + threadsPerBlock.z - <span class="hljs-number">1</span>) / threadsPerBlock.z)</span></span>;<br><br>    <span class="hljs-comment">// 调用CUDA内核函数</span><br>    <span class="hljs-type">int</span> inter_iL = <span class="hljs-number">4</span>, inter_iR = <span class="hljs-number">13</span> , inter_jL = <span class="hljs-number">4</span>, inter_jR = <span class="hljs-number">13</span>, inter_kL = <span class="hljs-number">4</span>, inter_kR = <span class="hljs-number">18</span>;<br>    processKernel&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(d_imark, d_cut_model, d_xyzside,d_array1D,d_array2D, d_array1,nx, ny, nz, w, <br>                                                      inter_iL, inter_iR, inter_jL, inter_jR, inter_kL, inter_kR, d_counter);<br><br>    <span class="hljs-comment">// 等待GPU完成</span><br>    <span class="hljs-built_in">hipDeviceSynchronize</span>();<br><br>    <span class="hljs-comment">// 将结果从GPU传回CPU</span><br>    <span class="hljs-built_in">hipMemcpy</span>(h_imark, d_imark, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_cut_model, d_cut_model, arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_xyzside, d_xyzside, arraySize4D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array2D,d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array2D,d_array2D,arraySize2D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(h_array1,d_array1,arraySize3D * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br>    <span class="hljs-built_in">hipMemcpy</span>(&amp;h_counter, d_counter, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), hipMemcpyDeviceToHost);<br><br>    <span class="hljs-comment">// 检查计数器</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total elements processed: &quot;</span> &lt;&lt; h_counter &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 打印结果（如果需要）</span><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; arraySize3D; i++) &#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; h_imark[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;*/</span><br>   <span class="hljs-comment">//只打印被改过的数据1500个</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   int sum = 0;</span><br><span class="hljs-comment">    for(int k = inter_kL;k&lt;=inter_kR;k++)&#123;</span><br><span class="hljs-comment">        for(int j = inter_jL;j&lt;=inter_jR;j++)&#123;</span><br><span class="hljs-comment">            for(int i = inter_iL;i&lt;=inter_iR;i++)&#123;               </span><br><span class="hljs-comment">                printf(&quot;%d&quot;,h_imark[k*(ny*nx)+j*nx+i]);</span><br><span class="hljs-comment">                sum++;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">    printf(&quot;sum = %d&quot;,sum);*/</span><br><br>    std::cout &lt;&lt; std::endl;<br><br>   <span class="hljs-comment">/*for (int i = 0; i &lt; arraySize4D; i++) &#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; h_xyzside[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    std::cout &lt;&lt; std::endl;*/</span><br><br>    <span class="hljs-comment">//只打印被改过的数据1500个</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = inter_kL;k&lt;=inter_kR;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = inter_jL;j&lt;=inter_jR;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = inter_iL;i&lt;=inter_iR;i++)&#123;               <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,h_xyzside[k * (ny * nx * w) + j * (nx * w) + i * w+<span class="hljs-number">0</span>],h_xyzside[k * (ny * nx * w) + j * (nx * w) + i * w+<span class="hljs-number">1</span>],h_xyzside[k * (ny * nx * w) + j * (nx * w) + i * w+<span class="hljs-number">2</span>]);<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d&quot;</span>,sum);<br>    <br><br>    <span class="hljs-comment">/*for(int i = 0;i&lt; arraySize2D;i++)&#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; h_array2D[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    std::cout &lt;&lt; std::endl;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    for(int i = 0;i&lt; arraySize1D;i++)&#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; h_array1D[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    std::cout &lt;&lt; std::endl;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    for (int i = 0; i &lt; arraySize3D; i++) &#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; h_array1[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    std::cout &lt;&lt; std::endl;*/</span><br><br><br>    <span class="hljs-comment">// 释放GPU内存</span><br>    <span class="hljs-built_in">hipFree</span>(d_imark);<br>    <span class="hljs-built_in">hipFree</span>(d_cut_model);<br>    <span class="hljs-built_in">hipFree</span>(d_xyzside);<br>    <span class="hljs-built_in">hipFree</span>(d_array2D);<br>    <span class="hljs-built_in">hipFree</span>(d_array1D);<br>    <span class="hljs-built_in">hipFree</span>(d_counter);<br><br>    <span class="hljs-comment">// 释放CPU内存</span><br>    <span class="hljs-keyword">delete</span>[] h_imark;<br>    <span class="hljs-keyword">delete</span>[] h_cut_model;<br>    <span class="hljs-keyword">delete</span>[] h_xyzside;<br>    <span class="hljs-keyword">delete</span>[] h_array1D;<br>    <span class="hljs-keyword">delete</span>[] h_array2D;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="先改完，再慢慢测，先测试US然后。。。设置一次迭代"><a href="#先改完，再慢慢测，先测试US然后。。。设置一次迭代" class="headerlink" title="先改完，再慢慢测，先测试US然后。。。设置一次迭代"></a>先改完，再慢慢测，先测试US然后。。。设置一次迭代</h4><p>RK的数组还没改完，测试核函数里面定义的变量，在不同线程中改，会不会混乱。定义的变量存在哪了？</p><p>每个维度的线程索引就对应数组的哪个维度的下标。</p><p>做ppt ？</p><h3 id="CUDA-线程模型"><a href="#CUDA-线程模型" class="headerlink" title="CUDA 线程模型"></a>CUDA 线程模型</h3><ol><li><strong>线程上下文</strong>：<ul><li>每个 CUDA 线程有自己的寄存器和本地内存。</li><li>当你在 <code>__global__</code> 函数中定义一个变量时，例如 <code>int dL;</code>，每个线程都有自己独立的 <code>dL</code> 变量，这些变量存储在线程的寄存器或本地内存中。</li><li>这些变量不会在不同线程之间共享，也不会互相干扰。</li></ul></li><li><strong>块和网格</strong>：<ul><li>CUDA 通过网格（grid）和块（block）来组织线程。</li><li>每个线程都有一个唯一的线程索引（thread index），这可以通过 <code>blockIdx</code> 和 <code>threadIdx</code> 获取。</li><li>基于线程索引，每个线程执行同样的代码，但操作不同的数据。</li></ul></li></ol><h3 id="对不同内存中数组的处理"><a href="#对不同内存中数组的处理" class="headerlink" title="对不同内存中数组的处理"></a>对不同内存中数组的处理</h3><p>从cpu中传入的多维数组，要通过显式数组下标的方式转换为一维数组</p><p>在<code>__global__</code>中定义的多维数组，可以直接访问数组下标，如<code>f[22][5]</code>,</p><p>在<code>__global__</code>中定义的数组和变量是每个线程私有的。在线程之间独立。</p><h3 id="常量传递"><a href="#常量传递" class="headerlink" title="常量传递"></a>常量传递</h3><p>如果要使用 <code>hipMemcpy</code> 函数，你可以用它来传递设备内存中的数据。虽然 <code>hipMemcpy</code> 用于处理普通的设备内存拷贝操作，而 <code>hipMemcpyToSymbol</code> 更适合处理常量内存的拷贝，但如果你希望将数据从主机拷贝到设备内存中的常量区域，<code>hipMemcpyToSymbol</code> 是更合适的方法。</p><h3 id="c转c-注意的问题"><a href="#c转c-注意的问题" class="headerlink" title="c转c++注意的问题"></a>c转c++注意的问题</h3><p>c++函数参数的数组要写成<code>***</code>三维，不要定义数组的大小。</p><p>可能出现的问题，常量到底在哪定义的，main和核函数中都有<code>__constant__</code></p><p>待解决：US,xyz:找不到device函数，找不到Fluidone,但是ASUM能找到Fluidone。device能调用device，写在一块？</p><p>写个测试程序试试能不能调用device函数，使用了分离编译可以了，目前还不能确定行不行。</p><h3 id="分离编译（Separate-Compilation）和链接"><a href="#分离编译（Separate-Compilation）和链接" class="headerlink" title="分离编译（Separate Compilation）和链接"></a>分离编译（Separate Compilation）和链接</h3><p>在 GPU 编程中，尤其是使用 HIP 或 CUDA 时，设备函数（标记为 <code>__device__</code> 的函数）默认情况下只能在同一个编译单元（即同一个源文件）内被调用。这意味着，如果你在一个文件中定义了设备函数，却试图在另一个文件中调用它，编译器会在链接阶段找不到该函数，导致 <strong>undefined symbol</strong> 错误。</p><h4 id="启用分离编译"><a href="#启用分离编译" class="headerlink" title="启用分离编译"></a>启用分离编译</h4><p>通过启用分离编译，编译器能够生成适用于多编译单元的设备代码。分离编译允许你：</p><ul><li>将设备代码分开编译，然后在链接阶段合并。</li><li>在不同的源文件中定义和调用设备函数。</li></ul><h4 id="编译和链接的步骤"><a href="#编译和链接的步骤" class="headerlink" title="编译和链接的步骤"></a>编译和链接的步骤</h4><p>在你的情况下，通过使用 <code>-fgpu-rdc</code> 选项，可以解决 undefined symbol 错误：</p><ol><li><p><strong>编译每个源文件为目标文件</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bash<br>复制代码<br>hipcc -fgpu-rdc -c fun_dev2<span class="hljs-selector-class">.cu</span> -o fun_dev2<span class="hljs-selector-class">.o</span><br>hipcc -fgpu-rdc -c test2<span class="hljs-selector-class">.cpp</span> -o test2.o<br></code></pre></td></tr></table></figure><ul><li>这里的 <code>-fgpu-rdc</code> 告诉编译器为分离编译生成设备代码。</li></ul></li><li><p><strong>链接所有目标文件</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">bash<br>复制代码<br>hipcc -fgpu-rdc test2<span class="hljs-selector-class">.o</span> fun_dev2<span class="hljs-selector-class">.o</span> -o test<br></code></pre></td></tr></table></figure><ul><li>在链接阶段，同样使用 <code>-fgpu-rdc</code> 选项，以确保链接器能够解析所有设备函数调用。</li></ul></li></ol><p><img src="/../images/1721914186493.png" alt="1721914186493"></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c转hipc</title>
    <link href="/2024/07/09/cTohipc/"/>
    <url>/2024/07/09/cTohipc/</url>
    
    <content type="html"><![CDATA[<h1 id="c转hipc"><a href="#c转hipc" class="headerlink" title="c转hipc"></a>c转hipc</h1><p>cuda 类比 hip</p><p>如果您将 <code>add</code> 和 <code>myKernel</code> 函数分别写在不同的文件中，并希望在主函数中调用 <code>myKernel</code> 函数，需要进行以下步骤：</p><ol><li><p><strong>定义 add 函数的头文件</strong>：创建一个头文件（例如 <code>cuda_functions.h</code>），在其中声明 <code>add</code> 函数为 <code>__device__</code> 函数。myKernel函数为<code>__global__</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp<br><span class="hljs-comment">// cuda_functions.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CUDA_FUNCTIONS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CUDA_FUNCTIONS_H</span><br><br><span class="hljs-function">__device__ <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">myKernel</span><span class="hljs-params">(<span class="hljs-type">int</span> *array, <span class="hljs-type">int</span> N)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// CUDA_FUNCTIONS_H</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>实现 add 函数的源文件</strong>：创建一个源文件（例如 <code>cuda_functions.cu</code>），在其中定义 <code>add</code> 函数的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp<br><span class="hljs-comment">// cuda_functions.cu</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda_functions.h&quot;</span></span><br><br><span class="hljs-function">__device__ <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>定义 myKernel 函数的源文件</strong>：创建另一个源文件（例如 <code>my_kernel.cu</code>），在其中定义 <code>myKernel</code> 函数。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan">cpp<br><span class="hljs-comment">// my_kernel.cu</span><br><br><span class="hljs-meta">#include &quot;<span class="hljs-string">cuda_functions.h</span>&quot;</span><br><br>__global__ <span class="hljs-type">void</span> myKernel(<span class="hljs-type">int</span> *<span class="hljs-type">array</span>, <span class="hljs-type">int</span> N) &#123;<br>    <span class="hljs-type">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">if</span> (idx &lt; N) &#123;<br>        <span class="hljs-comment">// 调用子函数</span><br>        <span class="hljs-type">array</span>[idx] = add(<span class="hljs-type">array</span>[idx], <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>主函数中的调用</strong>：在主函数中包含头文件 <code>cuda_functions.h</code>，并调用 <code>myKernel</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp<br><span class="hljs-comment">// main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda_functions.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> array[N];<br><br>    <span class="hljs-type">int</span> *d_array;<br>    <span class="hljs-built_in">cudaMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_array, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">cudaMemcpy</span>(d_array, array, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), cudaMemcpyHostToDevice);<br><br>    <span class="hljs-type">int</span> blockSize = <span class="hljs-number">256</span>;<br>    <span class="hljs-type">int</span> numBlocks = (N + blockSize - <span class="hljs-number">1</span>) / blockSize;<br>    myKernel&lt;&lt;&lt;numBlocks, blockSize&gt;&gt;&gt;(d_array, N);<br><br>    <span class="hljs-built_in">cudaMemcpy</span>(array, d_array, N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), cudaMemcpyDeviceToHost);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Modified array:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        std::cout &lt;&lt; array[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-built_in">cudaFree</span>(d_array);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>编译</strong>：在编译时，需要将所有 <code>.cu</code> 文件都传递给CUDA编译器 <code>nvcc</code>，并链接相应的CUDA库。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nvcc -o my_program <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> cuda_functions<span class="hljs-selector-class">.cu</span> my_kernel.cu<br></code></pre></td></tr></table></figure></li></ol><p>通过这样的方式，您可以将 CUDA 核函数和其它设备函数分别放置在不同的文件中，并在主函数中正确地调用和使用它们。</p>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gemm优化（代码实现）</title>
    <link href="/2024/07/07/gemm%E4%BC%98%E5%8C%96_%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/07/07/gemm%E4%BC%98%E5%8C%96_%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/442930482">深入浅出GPU优化系列：GEMM优化（二） - 知乎 (zhihu.com)</a></p><p>代码：</p><p><a href="https://github.com/Liu-xiandong/How_to_optimize_in_GPU/tree/master/sgemm">How_to_optimize_in_GPU&#x2F;sgemm at master · Liu-xiandong&#x2F;How_to_optimize_in_GPU (github.com)</a></p><h2 id="2-1-参数说明"><a href="#2-1-参数说明" class="headerlink" title="2.1 参数说明"></a>2.1 参数说明</h2><p>模板参数是GEMM性能调优的关键。不同参数对GEMM性能的影响很大。以下是主要模板参数的说明：</p><ul><li><code>BLOCK_SIZE_M</code>: 每个块计算的C矩阵的高度。</li><li><code>BLOCK_SIZE_K</code>: 每个块从A矩阵加载到共享内存的宽度。</li><li><code>BLOCK_SIZE_N</code>: 每个块计算的C矩阵的宽度。</li><li><code>THREAD_SIZE_Y</code>: 每个线程计算的C矩阵的高度。</li><li><code>THREAD_SIZE_X</code>: 每个线程计算的C矩阵的宽度。</li><li><code>ENABLE_DOUBLE_BUFFER</code>: 是否启用双缓冲（数据预取）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_SIZE_M,<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_SIZE_K,<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BLOCK_SIZE_N,<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> THREAD_SIZE_Y,<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> THREAD_SIZE_X,<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> ENABLE_DOUBLE_BUFFER<br>    &gt;<br></code></pre></td></tr></table></figure><p>接下来是线程的相关参数。256个block按照二维形态排布，每个block中有256个线程，同样以二维形态排布。以下是主要线程参数的说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Block index</span><br><span class="hljs-type">int</span> bx = blockIdx.x;<br><span class="hljs-type">int</span> by = blockIdx.y;<br><br><span class="hljs-comment">// Thread index</span><br><span class="hljs-type">int</span> tx = threadIdx.x;<br><span class="hljs-type">int</span> ty = threadIdx.y;<br><br><span class="hljs-comment">// the threads number in Block of X,Y</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> THREAD_X_PER_BLOCK = BLOCK_SIZE_N / THREAD_SIZE_X;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> THREAD_Y_PER_BLOCK = BLOCK_SIZE_M / THREAD_SIZE_Y;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> THREAD_NUM_PER_BLOCK = THREAD_X_PER_BLOCK * THREAD_Y_PER_BLOCK;<br><br><span class="hljs-comment">// thread id in cur Block</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> tid = ty * THREAD_X_PER_BLOCK + tx;<br></code></pre></td></tr></table></figure><p>在global memory到shared memory的数据搬运中，还需要经过寄存器。以下是一些共享内存和寄存器的分配说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// shared memory</span><br>__shared__ <span class="hljs-type">float</span> As[<span class="hljs-number">2</span>][BLOCK_SIZE_K][BLOCK_SIZE_M];<br>__shared__ <span class="hljs-type">float</span> Bs[<span class="hljs-number">2</span>][BLOCK_SIZE_K][BLOCK_SIZE_N];<br><span class="hljs-comment">// registers for C</span><br><span class="hljs-type">float</span> accum[THREAD_SIZE_Y][THREAD_SIZE_X] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// registers for A and B</span><br><span class="hljs-comment">//计算时用到的寄存器，存储每一轮小迭代存储的数据</span><br><span class="hljs-type">float</span> frag_a[<span class="hljs-number">2</span>][THREAD_SIZE_Y];<br><span class="hljs-type">float</span> frag_b[<span class="hljs-number">2</span>][THREAD_SIZE_X];<br><span class="hljs-comment">// registers load global memory</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ldg_num_a = BLOCK_SIZE_M * BLOCK_SIZE_K / (THREAD_NUM_PER_BLOCK * <span class="hljs-number">4</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ldg_num_b = BLOCK_SIZE_K * BLOCK_SIZE_N / (THREAD_NUM_PER_BLOCK * <span class="hljs-number">4</span>);<br><span class="hljs-comment">//从global mem &gt; share mem 中间需要的寄存器</span><br><span class="hljs-type">float</span> ldg_a_reg[<span class="hljs-number">4</span>*ldg_num_a];<br><span class="hljs-type">float</span> ldg_b_reg[<span class="hljs-number">4</span>*ldg_num_b];<br></code></pre></td></tr></table></figure><p>为了优化内存访问，我们定义了一些宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET(row, col, ld) ((row) * (ld) + (col))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FETCH_FLOAT4(pointer) (reinterpret_cast<span class="hljs-string">&lt;float4*&gt;</span>(&amp;(pointer))[0])</span><br></code></pre></td></tr></table></figure><p><strong>define OFFSET(row, col, ld) ((row) * (ld) + (col)):</strong></p><p>该宏用于计算二维数组在一维内存中的偏移量。</p><p><strong>#define FETCH_FLOAT4(pointer) (reinterpret_cast&lt;float4*&gt;(&amp;(pointer))[0])</strong></p><p>该宏用于一次性读取4个连续的<code>float</code>数据。</p><p><strong>解释</strong></p><ul><li>&amp;(pointer)：获取pointer的地址。</li><li><code>reinterpret_cast&lt;float4*&gt;(&amp;(pointer))</code>：将<code>pointer</code>的地址强制转换为指向<code>float4</code>类型的指针。<code>float4</code>是CUDA中的一种数据类型，表示包含4个<code>float</code>的向量。</li><li><code>[0]</code>：解引用该指针，获取<code>float4</code>类型的值。</li></ul><p>这实际上是从内存中读取4个连续的<code>float</code>值，并将它们作为一个<code>float4</code>返回。</p><p><strong>举例</strong></p><p>假设我们有一个连续的<code>float</code>数组：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">cpp<br>复制代码<br><span class="hljs-built_in">float</span> A[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>&#125;;<br></code></pre></td></tr></table></figure><p>如果我们希望一次性读取前4个值，可以使用该宏：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">cpp<br>复制代码<br><span class="hljs-built_in">float</span>4 f4 = FETCH_FLOAT4(A[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 结果是 f4.x = 0.0, f4.y = 1.0, f4.z = 2.0, f4.w = 3.0</span><br></code></pre></td></tr></table></figure><h2 id="2-2-大迭代前预取数据"><a href="#2-2-大迭代前预取数据" class="headerlink" title="2.2 大迭代前预取数据"></a>2.2 大迭代前预取数据</h2><p>迭代前预取数据分为<strong>两个部分</strong>，<strong>第一个部分</strong>是将第一个大迭代的数据从global 预取到shared memroy中。<strong>第二个部分</strong>是将shared memory上的数据预取到寄存器中。</p><p>第一个部分**是将第一个大迭代的数据从global 预取到shared memroy中。</p><p>先来看看<strong>第一个部分</strong>。这里面分别是将第一个大迭代中需要的A、B数据预取到shared memroy中。对于A矩阵而言，这个for循环代表着block中的线程需要搬运多少次才能将globa中的数据放到shared memory中。由于A需要先进行一次转置，所以先将数据先放置在寄存器中。数据按行取，然后按列存。对于B矩阵而言，数据不用转置，直接按行取，按行存。当然，这个过程中间也要经过寄存器，但是没有写出来的必要了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// load A from global memory to shared memory</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_M; i += A_TILE_ROW_STRIDE) &#123;<br>    <span class="hljs-type">int</span> ldg_index = i / A_TILE_ROW_STRIDE * <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//先将一个大迭代的数据读取到global mem &gt; shread mem 中间的寄存器中</span><br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(ldg_a_reg[ldg_index]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(A[<span class="hljs-built_in">OFFSET</span>(<br>        BLOCK_SIZE_M * by + A_TILE_ROW_START + i, <span class="hljs-comment">// row</span><br>        A_TILE_COL, <span class="hljs-comment">// col</span><br>        K )]);<br>    <span class="hljs-comment">//再将寄存器的数据读取到shared mem 中，这样就完成了第一次大迭代的数据预取</span><br>    As[<span class="hljs-number">0</span>][A_TILE_COL][A_TILE_ROW_START + i]=ldg_a_reg[ldg_index];<br>    As[<span class="hljs-number">0</span>][A_TILE_COL+<span class="hljs-number">1</span>][A_TILE_ROW_START + i]=ldg_a_reg[ldg_index+<span class="hljs-number">1</span>];<br>    As[<span class="hljs-number">0</span>][A_TILE_COL+<span class="hljs-number">2</span>][A_TILE_ROW_START + i]=ldg_a_reg[ldg_index+<span class="hljs-number">2</span>];<br>    As[<span class="hljs-number">0</span>][A_TILE_COL+<span class="hljs-number">3</span>][A_TILE_ROW_START + i]=ldg_a_reg[ldg_index+<span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-comment">// load B from global memory to shared memory</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_K; i += B_TILE_ROW_STRIDE) &#123;<br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(Bs[<span class="hljs-number">0</span>][B_TILE_ROW_START + i][B_TILE_COL]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(B[<span class="hljs-built_in">OFFSET</span>(<br>        B_TILE_ROW_START + i, <span class="hljs-comment">// row</span><br>        B_TILE_COL + BLOCK_SIZE_N * bx, <span class="hljs-comment">// col</span><br>        N )]);<br>&#125;<br>__syncthreads();<br></code></pre></td></tr></table></figure><p>第二个部分**是将shared memory上的数据预取到寄存器中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// load A from shared memory to register</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; thread_y += <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_a[<span class="hljs-number">0</span>][thread_y]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(As[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][THREAD_SIZE_Y * ty + thread_y]);<br>&#125;<br><br><span class="hljs-comment">// load B from shared memory to register</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; thread_x += <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_b[<span class="hljs-number">0</span>][thread_x]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(Bs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][THREAD_SIZE_X * tx + thread_x]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-大迭代逻辑"><a href="#2-3-大迭代逻辑" class="headerlink" title="2.3 大迭代逻辑"></a>2.3 大迭代逻辑</h2><p>每个大迭代加载新的数据块，并执行一系列的小迭代。我们先设置一些参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> write_stage_idx = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> tile_idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    tile_idx += BLOCK_SIZE_K;<br>    <span class="hljs-type">int</span> load_stage_idx = write_stage_idx ^ <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// compute</span><br>    <span class="hljs-keyword">if</span> (tile_idx &lt; K) &#123;<br>        write_stage_idx ^= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (tile_idx &lt; K);<br></code></pre></td></tr></table></figure><h2 id="2-4-大迭代详细解析"><a href="#2-4-大迭代详细解析" class="headerlink" title="2.4 大迭代详细解析"></a>2.4 大迭代详细解析</h2><h3 id="1-在大迭代中，我们将global-memory的数据块搬运到中间寄存器："><a href="#1-在大迭代中，我们将global-memory的数据块搬运到中间寄存器：" class="headerlink" title="1.在大迭代中，我们将global memory的数据块搬运到中间寄存器："></a>1.在大迭代中，我们将global memory的数据块搬运到中间寄存器：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">tile_idx += BLOCK_SIZE_K;<br><span class="hljs-keyword">if</span> (tile_idx &lt; K) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_M; i += A_TILE_ROW_STRIDE) &#123;<br>        <span class="hljs-type">int</span> ldg_index = i / A_TILE_ROW_STRIDE * <span class="hljs-number">4</span>;<br>        <span class="hljs-built_in">FETCH_FLOAT4</span>(ldg_a_reg[ldg_index]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(A[<span class="hljs-built_in">OFFSET</span>(<br>            BLOCK_SIZE_M * by + A_TILE_ROW_START + i, <span class="hljs-comment">// row</span><br>            A_TILE_COL + tile_idx, <span class="hljs-comment">// col</span><br>            K )]);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_K; i += B_TILE_ROW_STRIDE) &#123;<br>        <span class="hljs-type">int</span> ldg_index = i / A_TILE_ROW_STRIDE * <span class="hljs-number">4</span>;<br>        <span class="hljs-built_in">FETCH_FLOAT4</span>(ldg_b_reg[ldg_index]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(B[<span class="hljs-built_in">OFFSET</span>(<br>            tile_idx + B_TILE_ROW_START + i, <span class="hljs-comment">// row</span><br>            B_TILE_COL + BLOCK_SIZE_N * bx, <span class="hljs-comment">// col</span><br>            N )]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-进入小迭代的计算逻辑：将shared-mem-的数据存储到寄存器中"><a href="#2-进入小迭代的计算逻辑：将shared-mem-的数据存储到寄存器中" class="headerlink" title="2.进入小迭代的计算逻辑：将shared mem 的数据存储到寄存器中"></a>2.进入小迭代的计算逻辑：将shared mem 的数据存储到寄存器中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> load_stage_idx = write_stage_idx ^ <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; BLOCK_SIZE_K - <span class="hljs-number">1</span>; ++j) &#123;<br>    <span class="hljs-comment">// load next tile from shared mem to register </span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; thread_y += <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_a[(j + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][thread_y]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(As[load_stage_idx][j + <span class="hljs-number">1</span>][THREAD_SIZE_Y * ty + thread_y]);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; thread_x += <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_b[(j + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][thread_x]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(Bs[load_stage_idx][j + <span class="hljs-number">1</span>][THREAD_SIZE_X * tx + thread_x]);<br>    &#125;<br>    <span class="hljs-comment">// compute C THREAD_SIZE_X x THREAD_SIZE_Y</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; ++thread_y) &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; ++thread_x) &#123;<br>            accum[thread_y][thread_x] += frag_a[j % <span class="hljs-number">2</span>][thread_y] * frag_b[j % <span class="hljs-number">2</span>][thread_x];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-将数据从寄存器搬运到shared-memory："><a href="#3-将数据从寄存器搬运到shared-memory：" class="headerlink" title="3.将数据从寄存器搬运到shared memory："></a>3.将数据从寄存器搬运到shared memory：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (tile_idx &lt; K) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_M; i += A_TILE_ROW_STRIDE) &#123;<br>        <span class="hljs-type">int</span> ldg_index = i / A_TILE_ROW_STRIDE * <span class="hljs-number">4</span>;<br>        As[write_stage_idx][A_TILE_COL][A_TILE_ROW_START + i] = ldg_a_reg[ldg_index];<br>        As[write_stage_idx][A_TILE_COL + <span class="hljs-number">1</span>][A_TILE_ROW_START + i] = ldg_a_reg[ldg_index + <span class="hljs-number">1</span>];<br>        As[write_stage_idx][A_TILE_COL + <span class="hljs-number">2</span>][A_TILE_ROW_START + i] = ldg_a_reg[ldg_index + <span class="hljs-number">2</span>];<br>        As[write_stage_idx][A_TILE_COL + <span class="hljs-number">3</span>][A_TILE_ROW_START + i] = ldg_a_reg[ldg_index + <span class="hljs-number">3</span>];<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_SIZE_K; i += B_TILE_ROW_STRIDE) &#123;<br>        <span class="hljs-built_in">FETCH_FLOAT4</span>(Bs[write_stage_idx][B_TILE_ROW_START + i][B_TILE_COL]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(ldg_b_reg[ldg_index]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-最后，将shared-memory的数据块加载到寄存器，完成寄存器的预取，并将最后一个小迭代完成"><a href="#4-最后，将shared-memory的数据块加载到寄存器，完成寄存器的预取，并将最后一个小迭代完成" class="headerlink" title="4.最后，将shared memory的数据块加载到寄存器，完成寄存器的预取，并将最后一个小迭代完成"></a>4.最后，将shared memory的数据块加载到寄存器，完成寄存器的预取，并将最后一个小迭代完成</h3><p>“最后一个小迭代？”是为了处理前七次迭代没有处理过的最后的一部分矩阵相乘。“最后完成寄存器的预取”这一部分是为下一次大迭代的第一次小迭代进行预取，不是为了本次大迭代的最后一次小迭代预取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// load A from shared memory to register</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; thread_y += <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_a[<span class="hljs-number">0</span>][thread_y]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(As[write_stage_idx][<span class="hljs-number">0</span>][THREAD_SIZE_Y * ty + thread_y]);<br>&#125;<br><span class="hljs-comment">// load B from shared memory to register</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; thread_x += <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">FETCH_FLOAT4</span>(frag_b[<span class="hljs-number">0</span>][thread_x]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(Bs[write_stage_idx][<span class="hljs-number">0</span>][THREAD_SIZE_X * tx + thread_x]);<br>&#125;<br><span class="hljs-comment">//compute last tile mma THREAD_SIZE_X x THREAD_SIZE_Y</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; ++thread_y) &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; ++thread_x) &#123;<br>        accum[thread_y][thread_x] += frag_a[<span class="hljs-number">1</span>][thread_y] * frag_b[<span class="hljs-number">1</span>][thread_x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-计算结果写回"><a href="#5-计算结果写回" class="headerlink" title="5.计算结果写回"></a>5.计算结果写回</h3><p>此时，最后的计算结果已经被存储在<code>accum</code>寄存器中，需要将其写回到global memory中。这个代码比较简单，就没啥好说的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// store back to C</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_y = <span class="hljs-number">0</span>; thread_y &lt; THREAD_SIZE_Y; ++thread_y) &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unroll</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> thread_x = <span class="hljs-number">0</span>; thread_x &lt; THREAD_SIZE_X; thread_x+=<span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-built_in">FETCH_FLOAT4</span>(C[<span class="hljs-built_in">OFFSET</span>(<br>                BLOCK_SIZE_M * by + ty * THREAD_SIZE_Y + thread_y,<br>                BLOCK_SIZE_N * bx + tx * THREAD_SIZE_X + thread_x,<br>                N)]) = <span class="hljs-built_in">FETCH_FLOAT4</span>(accum[thread_y][thread_x]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过采用数据预取和双缓冲技术，我们可以大大提高GEMM的计算效率。这种方法确保了在大部分计算过程中，计算单元都在忙碌地进行计算，而不是在等待数据传输。这种优化方法在大型矩阵乘法中尤其有效。</p>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纪念</title>
    <link href="/2024/07/03/%E7%BA%AA%E5%BF%B5/"/>
    <url>/2024/07/03/%E7%BA%AA%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>今天没开组会，结束了一轮的训练</p><p>找到了很好看的美剧，无耻之徒</p><p>明天是我的生日，有谁会记得呢？</p><p>23岁结束，24岁，加油</p><p>明天下雨，早上好好睡觉吧，休息一下吧，晚上吃点好的。</p><p><img src="/../images/1720012074393.png" alt="1720012074393"></p><p>尺度有点大</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gemm优化</title>
    <link href="/2024/07/02/gemm%E4%BC%98%E5%8C%96/"/>
    <url>/2024/07/02/gemm%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Gemm-优化"><a href="#Gemm-优化" class="headerlink" title="Gemm 优化"></a>Gemm 优化</h1><p><strong>参考资料</strong></p><p><a href="https://zhuanlan.zhihu.com/p/435908830">深入浅出GPU优化系列：GEMM优化（一） - 知乎 (zhihu.com)</a></p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p><strong>分块是针对整个问题，先成条，即每个block，再分成block的每一次大迭代，再分成大迭代中的每次小迭代。</strong></p><p><strong>先分成条（block），再分成更小的条（大迭代），再分。</strong></p><p>取bm&#x3D;128,bn&#x3D;128,bk&#x3D;8,rm&#x3D;8,rn&#x3D;8</p><p>A，B，C，其维度都是2048×2048</p><p>要求解C&#x3D;A×B。那么我们需要开启（2048&#x2F;128）×（2048&#x2F;128）&#x3D;<strong>256个block</strong>，</p><p>每个block里面有（128&#x2F;8）×（128&#x2F;8）&#x3D;<strong>256个线程</strong>，</p><p>每个线程需要负责计算C矩阵中8×8&#x3D;64个元素的结果，每个block负责256×64&#x3D;16384个元素的结果。</p><p><img src="/../images/1719926905491.png" alt="1719926905491"></p><p>一个block算的是，128 × 2048 ，2048 × 128 ，大长条（block）。</p><p><img src="/../images/1719927479717.png" alt="1719927479717"></p><p><img src="/../images/1719927489368.png" alt="1719927489368"></p><p>block中有K次大迭代，K&#x3D; k&#x2F;bk&#x3D;2048&#x2F;8 &#x3D; 256，一次大迭代算的是128 × 8     8 × 128</p><p>小条（大迭代）</p><p><img src="/../images/1719927530708.png" alt="1719927530708"></p><p><img src="/../images/1719927534500.png" alt="1719927534500"></p><p>bk &#x3D; 8 每个线程有8次小迭代，一次小迭代算的是 8 × 1   1 × 8</p><p>更小的条（小迭代），把上面的图放大</p><p><img src="/../images/1719927620368.png" alt="1719927620368"></p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><strong>迭代是针对一个block进行的，每一个block都要进行256次大迭代，每个大迭代里面又有8个小迭代</strong></p><p><strong>即：写代码的逻辑</strong></p><p>明确了上面的参数之后，我们来仔细地观察其中<strong>一个block</strong>的计算逻辑。对于这个block而言，它需要进行2048&#x2F;8&#x3D;256次迭代，我们先把这个迭代称为<strong>大迭代</strong>，每一次大迭代都需要把A里面128×8&#x3D;1024个元素和B里面8×128&#x3D;1024个元素先放到shared memory中。然后这个block中的256个线程把结果计算出来。计算完之后，再进入下一次大迭代。不断重复该过程，直至这个block负责的16384个元素的结果被求解出。大迭代示意图如下：</p><p><img src="/../images/1719926415038.png" alt="1719926415038"></p><p>随后再具体看看每一个大迭代中，block中的线程的计算逻辑。在进行一个大迭代时，shared memory中有128×8&#x3D;1024个A矩阵元素和8×128&#x3D;1024个B矩阵元素。随后，每个线程需要进行8次迭代，我们把这个迭代成为<strong>小迭代</strong>。bk&#x3D;8，所以有8次小迭代。每一次小迭代中，每个线程需要从shared memory中拿到A矩阵的一小列和B矩阵的一小行，即8个A的元素和8个B的元素。线程将这8+8&#x3D;16个元素放置在寄存器中。每个线程需要负责8×8&#x3D;64个元素的计算，一共会产生64条FFMA指令。小迭代示意图如下：</p><p><img src="/../images/1719926427313.png" alt="1719926427313"></p><p>总的来说，<strong>对于一个block而言，有256个大迭代，每个大迭代中又有8个小迭代</strong></p><p>总之很绕，看了好久，脑子里有个模糊的概念了。然后看代码的实现吧，明天开组会讲点啥呢？</p>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gemm+im2col</title>
    <link href="/2024/07/01/gemm_im2col/"/>
    <url>/2024/07/01/gemm_im2col/</url>
    
    <content type="html"><![CDATA[<h2 id="gemm-im2col"><a href="#gemm-im2col" class="headerlink" title="gemm+im2col"></a>gemm+im2col</h2><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/taoqick/article/details/129051936">高性能卷积计算：img2col 原理详解-CSDN博客</a></p><p><a href="https://seanwangjs.github.io/2022/04/28/im2col-programming.html">使用 C++ 实现 im2col 操作 - Fenrier Lab (seanwangjs.github.io)</a></p><h3 id="im2col"><a href="#im2col" class="headerlink" title="im2col"></a>im2col</h3><p>img2col 是一种实现卷积操作的加速计算策略。它能将卷积操作转化为 GEMM，从而最大化地缩短卷积计算的时间。</p><h4 id="为什么要将卷积操作转化为-GEMM-呢？"><a href="#为什么要将卷积操作转化为-GEMM-呢？" class="headerlink" title="为什么要将卷积操作转化为 GEMM 呢？"></a><strong>为什么要将卷积操作转化为 GEMM 呢？</strong></h4><p>1.因为线性代数领域已经有非常成熟的计算接口（BLAS，Fortran 语言实现）来高效地实现大型的矩阵乘法，几乎可以做到极限优化。</p><p>2.将卷积过程中用到的所有特征子矩阵整合成一个大型矩阵存放在连续的内存中，虽然增加了存储成本，但是减少了内存访问的次数，从而缩短了计算时间。</p><h4 id="img2col将卷积操作转化为GEMM过程"><a href="#img2col将卷积操作转化为GEMM过程" class="headerlink" title="img2col将卷积操作转化为GEMM过程"></a>img2col将卷积操作转化为GEMM过程</h4><p><img src="/../images/1719824785939.png" alt="1719824785939"></p><h5 id="1-Input-Features-Input-Matrix"><a href="#1-Input-Features-Input-Matrix" class="headerlink" title="1.Input Features &gt; Input Matrix"></a>1.Input Features &gt; Input Matrix</h5><p><img src="/../images/1719824926813.png" alt="1719824926813"></p><p>输入特征图有三个通道，用三个不同的颜色来表示</p><p>因为卷积核的大小为2乘2，当卷积核的滑动步长为1的时候，那么传统的直接卷积计算一共需要进行 4 次卷积核与对应特征子矩阵之间的点积运算。</p><p>现在把每一个子矩阵都排列成一个行向量，就得到了三个通道的特征图对应的三个矩阵（Input Matrix）</p><h5 id="2-Convolution-Kernel-Kernel-Matrix"><a href="#2-Convolution-Kernel-Kernel-Matrix" class="headerlink" title="2.Convolution Kernel &gt; Kernel Matrix"></a>2.Convolution Kernel &gt; Kernel Matrix</h5><p><img src="/../images/1719825159189.png" alt="1719825159189"></p><p>卷积核有两个，每一个也是三通道的，我们研究其中一个卷积核</p><p>将卷积核转换为列向量，然后再把每一个通道对应的 Kernel Matrix 堆叠成一个完整的 Kernel Matrix。</p><h5 id="3-Input-Matrix-Kernel-Matrix-Output-Matrix"><a href="#3-Input-Matrix-Kernel-Matrix-Output-Matrix" class="headerlink" title="3.Input Matrix * Kernel Matrix &#x3D; Output Matrix"></a>3.Input Matrix * Kernel Matrix &#x3D; Output Matrix</h5><p>调用GEMM接口，将两个矩阵进行乘积。然后将输出矩阵通过 col2img 函数就可以得到和卷积运算一样的输出特征图。</p><p><img src="/../images/1719825458677.png" alt="1719825458677"></p><h4 id="c-代码实现im2col"><a href="#c-代码实现im2col" class="headerlink" title="c++代码实现im2col"></a>c++代码实现im2col</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">im2col</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>* data_im, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> im_c, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> im_w, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> im_h, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kw, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> kh, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ph, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> pw, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sh,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sw,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">float</span>* data_col, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> col_w, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">int</span> col_h)</span> </span>&#123;<br><br>        <span class="hljs-comment">// win_w and win_h are the stop times of the kernel in the image.</span><br>        <span class="hljs-type">int</span> win_w = (im_w + <span class="hljs-number">2</span> * pw - kw + <span class="hljs-number">1</span>) / sw;<br>        <span class="hljs-type">int</span> win_h = (im_h + <span class="hljs-number">2</span> * ph - kh + <span class="hljs-number">1</span>) / sh;<br><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; col_h; i++) &#123;<br><br>            x = i % win_w;<br>            y = i / win_w;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col_w; j++) &#123;<br>                <span class="hljs-type">int</span> c = j / (kw * kh);<br>                <span class="hljs-type">int</span> kj = j % kw;<br>                <span class="hljs-type">int</span> ki = j / kw;<br><br>                <span class="hljs-type">int</span> row = y * sh + ki;<br>                <span class="hljs-type">int</span> col = x * sw + kj;<br><br>                data_col[i * col_w + j] = <span class="hljs-built_in">get_data</span>(data_im, c, im_w, im_h, row, col, ph, pw);<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cublas库 学习</title>
    <link href="/2024/07/01/cublas%E5%BA%93/"/>
    <url>/2024/07/01/cublas%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="cublas库"><a href="#cublas库" class="headerlink" title="cublas库"></a>cublas库</h2><h3 id="what-is-cublas？"><a href="#what-is-cublas？" class="headerlink" title="what is cublas？"></a>what is cublas？</h3><p>CUDA Basic Linear Algebra Subprograms（BLAS）提供了高效计算线性代数的方法。</p><p>有三级API和cuBLAS 扩展、辅助API：</p><p>最基础操作，例如加、减、最大值、复制、转置<br>矩阵的一般操作，例如特殊类型矩阵的乘法、rank<br>更复杂一些的例子，例如“使用一般矩阵计算批量的矩阵-矩阵乘积”，‘使用高斯复杂度降低算法计算一般矩阵的矩阵-矩阵乘积’<br>API介绍：<a href="https://docs.nvidia.com/cuda/cublas/index.html">https://docs.nvidia.com/cuda/cublas/index.html</a></p><p>样例代码：<a href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLAS">https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLAS</a></p><p>功能：</p><p>向量和矩阵操作：包括向量加法、向量-标量乘法、向量点积等。<br>矩阵乘法：支持各种形式的矩阵乘法，包括方阵乘法、矩阵-向量乘法等。<br>分解和求逆：例如LU分解、Cholesky分解和矩阵求逆等。<br>求解线性系统：使用不同的方法解决线性方程组。</p><h3 id="实例程序："><a href="#实例程序：" class="headerlink" title="实例程序："></a>实例程序：</h3><p>计算三角带状矩阵向量乘法</p><p><a href="https://blog.csdn.net/prinTao/article/details/135634551">【cuda】六、基础库：cuBLAS入门-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hipblas.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime_api.h&gt;</span></span><br><br><span class="hljs-comment">//#include &lt;hipblas_utils.h&gt;</span><br><br><span class="hljs-keyword">using</span> data_type = <span class="hljs-type">double</span>; <span class="hljs-comment">//数据类型为double</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span></span>&#123;<br><span class="hljs-comment">//声明一个hipBLAS句柄</span><br>hipblasHandle_t hipblasH = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//声明一个HIP 流</span><br>hipStream_t stream = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<span class="hljs-comment">//矩阵A的行数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">2</span>;<span class="hljs-comment">//矩阵A的列数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<span class="hljs-comment">//定义超对角线元素的个数（用于三角矩阵的函数）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> lda = m;<span class="hljs-comment">//定义矩阵A的领先维度（leading dimension）</span><br><br><span class="hljs-comment">//初始化矩阵A和向量x</span><br><span class="hljs-comment">//std::vector 是c++标准库中的动态数组类，可以存储动态变化数量的元素</span><br><span class="hljs-type">const</span> std::vector&lt;data_type&gt; A = &#123;<span class="hljs-number">1.0</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">4.0</span>&#125;;<br>std::vector&lt;data_type&gt; x = &#123;<span class="hljs-number">5.0</span>,<span class="hljs-number">6.0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> incx = <span class="hljs-number">1</span>;<span class="hljs-comment">//x的步长</span><br><br>data_type *d_A = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//设备端的矩阵A</span><br>data_type *d_x = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//设备端的向量x</span><br><br><span class="hljs-comment">//hipBLAS的相关设置</span><br>hipblasFillMode_t uplo = HIPBLAS_FILL_MODE_UPPER;<span class="hljs-comment">//使用上三角形式</span><br>hipblasOperation_t transa = HIPBLAS_OP_N;<span class="hljs-comment">//矩阵A不进行转置</span><br>hipblasDiagType_t diag = HIPBLAS_DIAG_NON_UNIT;<span class="hljs-comment">//矩阵A的对角线元素不被视为1</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A\n&quot;</span>);<br><span class="hljs-comment">//print_matrix(m,n,A.data(),lda);</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;======\n&quot;</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x\n&quot;</span>);<br><span class="hljs-comment">//print_vector(x.size(),x.data());</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=====\n&quot;</span>);<br><br><span class="hljs-comment">//step1</span><br><span class="hljs-comment">//hipblasCreate(&amp;hipblasH);</span><br><br><br><br><br><br><br><br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="卡住了，hip和cuda-blas-库不同"><a href="#卡住了，hip和cuda-blas-库不同" class="headerlink" title="卡住了，hip和cuda  blas 库不同"></a>卡住了，hip和cuda  blas 库不同</h3><p>cuda的库#include &lt;cublas_utils.h&gt;在hip中#include &lt;hipblas_utils.h&gt;，不能调用</p><p>所以后面的一些库函数也无法调用。</p><p>cublas:</p><p>API介绍：<a href="https://docs.nvidia.com/cuda/cublas/index.html">https://docs.nvidia.com/cuda/cublas/index.html</a></p><p>样例代码：<a href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLAS">https://github.com/NVIDIA/CUDALibrarySamples/tree/master/cuBLAS</a></p><p>hipblas:</p><p><a href="https://rocmdocs.amd.com/projects/hipBLAS/en/latest/index.html">hipBLAS documentation — hipBLAS 2.1.0 Documentation (amd.com)</a></p><p>有时间再研究吧。。。。。</p><p>先用cuda试试</p><p>因为比赛是用的dcu卡，要用hip，这个方法以后再研究。</p>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce优化(补充)</title>
    <link href="/2024/06/30/reduce%E4%BC%98%E5%8C%96(%E8%A1%A5%E5%85%85)/"/>
    <url>/2024/06/30/reduce%E4%BC%98%E5%8C%96(%E8%A1%A5%E5%85%85)/</url>
    
    <content type="html"><![CDATA[<h3 id="优化6：调整Block大小"><a href="#优化6：调整Block大小" class="headerlink" title="优化6：调整Block大小"></a>优化6：调整Block大小</h3><p>保持每个block的线程数不变，一个线程处理一个数据，两个数据，四个数据。处理多少个数据比较合适呢，这个就需要试了，获得最优的NumPerThread取值。每个线程处理数据增大一倍，同时blockPerGrid 就要减少一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce6</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>        __shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock];<br>        <span class="hljs-comment">// 数组的全局索引也要变</span><br>        <span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * (blockDim.x * NumPerThread);<br>        <span class="hljs-type">int</span> tid = threadIdx.x;<br>        <span class="hljs-comment">// 累加一个线程处理的数据</span><br>        <span class="hljs-comment">// 一定要加上这句,确保在开始累加数据之前，它的值是 0</span><br>        sdata[tid] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;NumPerThread;j++)&#123;<br>                sdata[tid] += d_in[i + blockDim.x * j];<br>        &#125;<br>        __syncthreads();<br><br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">1024</span> &amp;&amp; tid &lt; <span class="hljs-number">512</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">512</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">512</span> &amp;&amp; tid &lt; <span class="hljs-number">256</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">256</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">256</span> &amp;&amp; tid &lt; <span class="hljs-number">128</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">128</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">128</span> &amp;&amp; tid &lt; <span class="hljs-number">64</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">64</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid &lt; <span class="hljs-number">32</span>)&#123;<br>                <span class="hljs-built_in">warpReduce</span>(sdata,tid);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid == <span class="hljs-number">0</span>)&#123;<br>                d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>        &#125;<br>&#125;<br><br>reduce6&lt;&lt;&lt;blocksPerGrid/NumPerThread,threadsPerBlock&gt;&gt;&gt;(d_a,d_partial_c);<br></code></pre></td></tr></table></figure><h3 id="优化7：shuffle指令"><a href="#优化7：shuffle指令" class="headerlink" title="优化7：shuffle指令"></a>优化7：shuffle指令</h3><h4 id="shuffle指令"><a href="#shuffle指令" class="headerlink" title="shuffle指令"></a>shuffle指令</h4><p>NV提出了Shuffle指令，对于reduce优化有着非常好的效果。目前绝大多数访存类算子，像是softmax，batch_norm，reduce等，都是用Shuffle实现。所以，在这里谈一下这么把shuffle指令用在reduce优化上。</p><p>Shuffle指令是一组针对warp的指令。Shuffle指令最重要的特性就是<strong>warp内的寄存器可以相互访问</strong>。在没有shuffle指令的时候，各个线程在进行通信时只能通过shared memory来访问彼此的寄存器。而采用了shuffle指令之后，<strong>warp内的线程可以直接对其他线程的寄存器进行访存</strong>。通过这种方式可以减少访存的延时。除此之外，带来的最大好处就是可编程性提高了，在某些场景下，<strong>就不用shared memory</strong>了。毕竟，开发者要自己去控制 shared memory还是挺麻烦的一个事。</p><p>以后有时间再研究</p>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce逐步优化</title>
    <link href="/2024/06/29/reduce%E4%BC%98%E5%8C%96/"/>
    <url>/2024/06/29/reduce%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h3><p><a href="https://zhuanlan.zhihu.com/p/426978026">深入浅出GPU优化系列：reduce优化 - 知乎 (zhihu.com)</a></p><h3 id="reduce-baseline-算法（基础规约算法）"><a href="#reduce-baseline-算法（基础规约算法）" class="headerlink" title="reduce baseline 算法（基础规约算法）"></a>reduce baseline 算法（基础规约算法）</h3><p>我们让Num_per_block与Thread_per_block一致，即一个线程处理一个数据，每个block设定为256个线程，一个block负责256个数据的reduce工作。</p><p>假设要处理32M（32*1024）个数据，那么需要的block数为 32M&#x2F;256 &#x3D; 128 个block。</p><p>tid代表每个block里面的线程号，i代表原数组的索引号，将原数组的值分配到每个shared memory 中</p><p>sdata[tid] &#x3D; d_in[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hip/hip_runtime_api.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 32768</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> threadsPerBlock = <span class="hljs-number">256</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> blocksPerGrid = <span class="hljs-number">128</span>;<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce0</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>__shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock];<br><br><span class="hljs-comment">//each thread loads one element form global memory to shared memory</span><br><span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;<br><span class="hljs-type">int</span> tid = threadIdx.x;<br>sdata[tid] = d_in[i];<br>__syncthreads();<br><br><span class="hljs-comment">//do reduction in shared memory</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;s&lt;blockDim.x;s*=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">if</span>(tid%(<span class="hljs-number">2</span>*s)==<span class="hljs-number">0</span>)&#123;<br>sdata[tid] += sdata[tid+s];<br>&#125;<br>__syncthreads();<br>&#125;<br><br><span class="hljs-comment">//wirte result for this block to global memory</span><br><span class="hljs-keyword">if</span>(tid ==<span class="hljs-number">0</span>)&#123;<br>d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><br><span class="hljs-type">int</span> a[N],partial_c[blocksPerGrid];<br><span class="hljs-type">long</span> c;<br><span class="hljs-type">int</span> *d_a,*d_partial_c;<br><span class="hljs-built_in">hipMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_a,N*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-built_in">hipMalloc</span>((<span class="hljs-type">void</span> **)&amp;d_partial_c,blocksPerGrid*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-comment">//initial</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>a[i] = i;<br>&#125;<br><span class="hljs-built_in">hipMemcpy</span>(d_a,a,N*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyHostToDevice);<br>reduce0&lt;&lt;&lt;blocksPerGrid,threadsPerBlock&gt;&gt;&gt;(d_a,d_partial_c);<br><span class="hljs-built_in">hipMemcpy</span>(partial_c,d_partial_c,blocksPerGrid*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>),hipMemcpyDeviceToHost);<br><br>c = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;blocksPerGrid;i++)&#123;<br>c += partial_c[i];<br>&#125;<br><br><span class="hljs-built_in">hipFree</span>(d_a);<br><span class="hljs-built_in">hipFree</span>(d_partial_c);<br><br><span class="hljs-comment">//check the result</span><br><span class="hljs-keyword">if</span>(c==<span class="hljs-number">32767</span>*<span class="hljs-number">32768</span>/<span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;success\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%ld&quot;</span>,c);<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="what-is-warp-and-bank"><a href="#what-is-warp-and-bank" class="headerlink" title="what is warp and bank"></a>what is warp and bank</h3><h4 id="warp"><a href="#warp" class="headerlink" title="warp:"></a>warp:</h4><p>并行计算时最小的并发结构，通常由连续32个thread组成,也称线程束。</p><h4 id="bank"><a href="#bank" class="headerlink" title="bank:"></a>bank:</h4><p>是对SM中共享内存的划分，划分个数与对应硬件warp中所含thread数一致。对应使用的计算能力3.x版本的显卡，一个warp含有32个thread，因此划分的bank数也为32，并且每个bank的宽度大小为4bytes，对应于一个int型或float型变量。</p><h3 id="优化1：解决warp-divergence"><a href="#优化1：解决warp-divergence" class="headerlink" title="优化1：解决warp divergence"></a>优化1：解决warp divergence</h3><h4 id="warp-divergence："><a href="#warp-divergence：" class="headerlink" title="warp divergence："></a>warp divergence：</h4><p>对于同一个warp中的所有thread是完全并行的，且必须要执行相同的指令，当同一warp中的thread分配了不同的指令时，会发生warp divergence，增加了程序的运行时间。为了有效地解决上述divergence问题，在分配任务时，尽量的使用索引号连续的thread，使活跃的thread全部集中到某些warp中，避免同一warp中同时存在活跃和不活跃两种状态的thread。</p><p>对于reduce算法问题，如果存在if-else这样的分支情况的话，thread会执行所有的分支。只是不满足条件的分支，所产生的结果不会记录下来。可以在图中看到，在每一轮迭代中都会产生两个分支，分别是红色和橙色的分支。这严重影响了代码执行的效率。其中红色的线程是符合if条件的线程，只有他们需要干活。</p><p><img src="/../images/1719653482706.png" alt="1719653482706"></p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>解决的方式也比较明了，就是尽可能地让所有线程走到同一个分支里面。</p><p>虽然代码依旧存在着if语句，但是却与reduce0代码有所不同。我们继续假定block中存在256个thread，即拥有256&#x2F;32&#x3D;8个warp。由于blockDim.x &#x3D; 256。对于3号warp，index &#x3D; 2乘tid&#x3D;2乘4乘32&#x3D;256，正好到第三个warp。当进行<strong>第1次迭代</strong>时，0-3号warp的index&lt;blockDim.x， 4-7号warp的index&gt;&#x3D;blockDim.x。对于每个warp而言，都只是进入到一个分支内，所以并不会存在warp divergence的情况。当进行<strong>第2次迭代</strong>时，0、1号两个warp进入计算分支。当进行<strong>第3次迭代</strong>时，只有0号warp进入计算分支。当进行<strong>第4次迭代</strong>时，只有0号warp的前16个线程进入分支。此时开始产生warp divergence。通过这种方式，我们消除了前3次迭代的warp divergence。</p><p>这样第一轮迭代只有前3个warp里面的连续线程是忙碌的，消除了warp divergence</p><h4 id="优化代码："><a href="#优化代码：" class="headerlink" title="优化代码："></a>优化代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce1</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>__shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock];<br><br><span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;<br><span class="hljs-type">int</span> tid = threadIdx.x;<br>sdata[tid] = d_in[i];<br>__syncthreads();<br><span class="hljs-comment">//do reduction in shared memory</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;s&lt;blockDim.x;s*=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-type">int</span> index = <span class="hljs-number">2</span>*tid*s;<br><span class="hljs-keyword">if</span>(index &lt; blockDim.x)&#123;<br>sdata[index] += sdata[index+s];<br>&#125;<br>__syncthreads();<br>&#125;<br><span class="hljs-comment">//wirte result for this block to global memory</span><br><span class="hljs-keyword">if</span>(tid == <span class="hljs-number">0</span>)&#123;<br>d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化2：解决bank冲突"><a href="#优化2：解决bank冲突" class="headerlink" title="优化2：解决bank冲突"></a>优化2：解决bank冲突</h3><h4 id="bank-conflict"><a href="#bank-conflict" class="headerlink" title="bank conflict:"></a>bank conflict:</h4><p> 一个SM中，共享内存会被分成多个bank，共享内存中以每4*32bytes为单位，顺序的存储在bank0~bank31中，当两个不同的thread同时访问同一bank内的值时，会发生bank conflict，也会增加程序运行的时间。</p><h4 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h4><p>reduce1的最大问题是<strong>bank冲突</strong>。我们把目光聚焦在这个for循环中。并且只聚焦在<strong>0号warp</strong>。在<strong>第一次迭代</strong>中，0号线程需要去load shared memory的0号地址以及1号地址的数，然后写回到0号地址。而此时，这个warp中的16号线程，需要去load shared memory中的32号地址和33号地址。可以发现，0号地址跟32号地址产生了<strong>2路的bank冲突</strong>。再往后迭代会出现更多路的bank冲突</p><p>slove：</p><p>在reduce中，解决bank冲突的方式就是把for循环逆着来。原来stride从0到256，现在stride从128到0。</p><p>把目光继续看到这个for循环中，并且只分析0号warp。0号线程需要load shared memory的0号元素以及128号元素。第2轮迭代，0号线程load 0号元素和64号元素，1号线程load 1号元素和65号元素。第3轮迭代，0号线程load 0号元素和32号元素。到了4轮迭代，0号线程load 0号元素和16号元素。15号线程load 15号元素和31号元素。那16号线程呢，16号线程啥也不干，因为s&#x3D;16，16-31号线程啥也不干，跳过去了。</p><h4 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce2</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>        __shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock];<br><br>        <span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;<br>        <span class="hljs-type">int</span> tid = threadIdx.x;<br>        sdata[tid] = d_in[i];<br>        __syncthreads();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = blockDim.x/<span class="hljs-number">2</span>;s&gt;<span class="hljs-number">0</span>;s/=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tid&lt;s)&#123;<br>                        sdata[tid] += sdata[tid+s];<br>                &#125;<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid==<span class="hljs-number">0</span>)&#123;<br>                d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>        &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化3：解决idle线程"><a href="#优化3：解决idle线程" class="headerlink" title="优化3：解决idle线程"></a>优化3：解决idle线程</h3><p>reduce2最大的问题就是线程的浪费。可以看到我们启动了256个线程，但是在第1轮迭代时只有128个线程在干活，第2轮迭代只有64个线程在干活，每次干活的线程都会减少一半。第一轮迭代示意图如下，只有前128个线程在load数据。后128个线程啥也不干，光看着。</p><p>每一轮迭代都有一半的线程不工作，要把所有的线程利用起来。</p><p>想来想去，那这样吧，让它好歹做一次加法。除了去global memory中取数外，再做一次加法。当然为了实现这个，block数就得改一改了。Block数量减少，Num_per_block增加一倍。也就是说原来一个block只需要管256个数就行，现在得管512个数了。</p><p>每个block还是256个线程，不同的地方在于每个block里边会处理512个数据，这样一来grid中block的数量也减少了一半。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce3</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>        __shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * (blockDim.x*<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> tid = threadIdx.x;<br>        sdata[tid] = d_in[i] + d_in[i + blockDim.x];<br>        __syncthreads();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = blockDim.x/<span class="hljs-number">2</span>;s&gt;<span class="hljs-number">0</span>;s/=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tid&lt;s)&#123;<br>                        sdata[tid] += sdata[tid + s];<br>                &#125;<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid==<span class="hljs-number">0</span>)&#123;<br>                d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>        &#125;<br><br>&#125;<br><br>reduce3&lt;&lt;&lt;blocksPerGrid/<span class="hljs-number">2</span>,threadsPerBlock&gt;&gt;&gt;(d_a,d_partial_c);<br></code></pre></td></tr></table></figure><h3 id="优化4：展开最后一维减少同步"><a href="#优化4：展开最后一维减少同步" class="headerlink" title="优化4：展开最后一维减少同步"></a>优化4：展开最后一维减少同步</h3><p>线程每一次迭代都减半。由于一个warp中的32个线程其实是在一个SIMD单元上，这32个线程每次都是执行同一条指令，这天然地保持了同步状态。当线程束&gt;32时需要同步，反之线程数&lt;32时，就不需要同步了。我们需要在这个时候将syncthreads操作去掉，减少同步所造成的时间浪费。</p><p>所以我们将最后一维进行展开以减少同步。</p><p>需要注意的是<strong>这个地方的cache变量需要使用volatile来进行声明</strong>，它告诉编译器每次赋值时必须将cache[tid]的值返回到全局内存中，而不是简单的读写缓存或寄存器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//__global__是kernel函数，可从cpu调用,__device__是只能从一个gpu函数调用，不能从cpu调用</span><br><span class="hljs-comment">//volatile 指出变量是随时可能发生变化的,与volatile变量有关的运算,不要进行编译优化,以免出错</span><br><span class="hljs-function">__device__ <span class="hljs-type">void</span> <span class="hljs-title">warpReduce</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *cache,<span class="hljs-type">int</span> tid)</span></span>&#123;<br>        cache[tid] += cache[tid+<span class="hljs-number">32</span>];<br>        cache[tid] += cache[tid+<span class="hljs-number">16</span>];<br>        cache[tid] += cache[tid+<span class="hljs-number">8</span>];<br>        cache[tid] += cache[tid+<span class="hljs-number">4</span>];<br>        cache[tid] += cache[tid+<span class="hljs-number">2</span>];<br>        cache[tid] += cache[tid+<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce4</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>        __shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * (blockDim.x*<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> tid = threadIdx.x;<br>        sdata[tid] = d_in[i] + d_in[i + blockDim.x];<br>        __syncthreads();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = blockDim.x/<span class="hljs-number">2</span>;s&gt;<span class="hljs-number">32</span>;s/=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tid&lt;s)&#123;<br>                        sdata[tid] += sdata[tid + s];<br>                &#125;<br>                __syncthreads();<br><br>        &#125;<br>        <span class="hljs-comment">//此时s = 32,因为tid&lt;s,只有一个warp里面32个线程了</span><br>        <span class="hljs-keyword">if</span>(tid&lt;<span class="hljs-number">32</span>)&#123;<br>                <span class="hljs-built_in">warpReduce</span>(sdata,tid);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid==<span class="hljs-number">0</span>)&#123;<br>                d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化5：完全展开"><a href="#优化5：完全展开" class="headerlink" title="优化5：完全展开"></a>优化5：完全展开</h3><p>对<strong>for循环</strong>进行完全展开，通过这种方式<strong>减少了条件判断的次数</strong>，因而可以实现速度的提升。</p><p>效果一般</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//reduce 完全展开</span><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">reduce5</span><span class="hljs-params">(<span class="hljs-type">int</span> *d_in,<span class="hljs-type">int</span> *d_out)</span></span>&#123;<br>        __shared__ <span class="hljs-type">int</span> sdata[threadsPerBlock*<span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">int</span> i = threadIdx.x + blockIdx.x * (blockDim.x*<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> tid = threadIdx.x;<br>        sdata[tid] = d_in[i] + d_in[i + blockDim.x];<br>        __syncthreads();<br><br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">1024</span> &amp;&amp; tid &lt; <span class="hljs-number">512</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">512</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">512</span> &amp;&amp; tid &lt; <span class="hljs-number">256</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">256</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;= <span class="hljs-number">256</span> &amp;&amp; tid &lt; <span class="hljs-number">128</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">128</span>];<br>                __syncthreads();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(blockDim.x &gt;=<span class="hljs-number">128</span> &amp;&amp; tid &lt; <span class="hljs-number">64</span>)&#123;<br>                sdata[tid] += sdata[tid + <span class="hljs-number">64</span>];<br>                __syncthreads();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(tid &lt; <span class="hljs-number">32</span>)&#123;<br>                <span class="hljs-built_in">warpReduce</span>(sdata,tid);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tid == <span class="hljs-number">0</span>)&#123;<br>                d_out[blockIdx.x] = sdata[<span class="hljs-number">0</span>];<br>        &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化6：调整Block大小"><a href="#优化6：调整Block大小" class="headerlink" title="优化6：调整Block大小"></a>优化6：调整Block大小</h3><h3 id="优化7：shuffle指令"><a href="#优化7：shuffle指令" class="headerlink" title="优化7：shuffle指令"></a>优化7：shuffle指令</h3>]]></content>
    
    
    <categories>
      
      <category>hpc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天气晴，明天有雨</title>
    <link href="/2024/06/28/%E9%9A%8F%E7%AC%941/"/>
    <url>/2024/06/28/%E9%9A%8F%E7%AC%941/</url>
    
    <content type="html"><![CDATA[<h4 id="搭建了我的博客"><a href="#搭建了我的博客" class="headerlink" title="搭建了我的博客"></a>搭建了我的博客</h4><p>github 文章永生</p><p>明天加油吧！！！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流体力学</title>
    <link href="/2024/06/28/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6/"/>
    <url>/2024/06/28/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>学习记录</p><p>1.流体研究的前提：连续介质假设<br>2.流体力学的物理量：速度，密度，压强，温度等</p><h3 id="描述流体运动的方法："><a href="#描述流体运动的方法：" class="headerlink" title="描述流体运动的方法："></a>描述流体运动的方法：</h3><p>①拉格朗日法：以一坨流体的某个质点为例，研究这个质点的随时间的变化，即盯着质点看。<br>②欧拉法：在空间取一个范围，即控制体，控制体（固定不动），如控制体中取某位置，研究该位置所在流体的性质，也就是盯着空间看。<br>●总结：拉格朗日法研究的是一坨流体（积分）或者说某个质点（微分）；欧拉法研究的是控制体（积分）或空间点（微分）</p><p><img src="/../images/1713422480785.png" alt="1713422480785"></p><h3 id="流体力学的任务（要解决什么问题）"><a href="#流体力学的任务（要解决什么问题）" class="headerlink" title="流体力学的任务（要解决什么问题）"></a>流体力学的任务（要解决什么问题）</h3><p>例子：血栓的形成，航天器内部气体的流动</p><p>研究一定条件下，任意时刻（t），任意位置（x,y,z）各种物理量（p，ρ，T，v）的分布</p><p>p(x,y,z,t),ρ（x,y,z,t）…..解这些函数，就涉及流体力学的基本方程。</p><h3 id="流体力学的基本方程（控制方程）"><a href="#流体力学的基本方程（控制方程）" class="headerlink" title="流体力学的基本方程（控制方程）"></a>流体力学的基本方程（控制方程）</h3><p>是一个方程组。</p><p>质量守恒</p><p>动量守恒（动量有三个方向，可以列三个方程）</p><p>能量守恒</p><p>要解6个值 P,ρ，T，t，v（u,v,w）速度有三个方向，一共是6个值</p><p>一共是5个方程，所以还要加一个流体力学本身具有的性质所列出的方程。</p><p><img src="/../images/1713423733375.png" alt="1713423733375"></p><h3 id="质量守恒方程（连续方程）"><a href="#质量守恒方程（连续方程）" class="headerlink" title="质量守恒方程（连续方程）"></a>质量守恒方程（连续方程）</h3><h4 id="积分形式的质量守恒"><a href="#积分形式的质量守恒" class="headerlink" title="积分形式的质量守恒"></a>积分形式的质量守恒</h4><p><img src="/../images/1713516753303.png" alt="1713516753303"></p><p><img src="/../images/1713516816649.png" alt="1713516816649"></p><h4 id="微分形式的质量守恒方程"><a href="#微分形式的质量守恒方程" class="headerlink" title="微分形式的质量守恒方程"></a>微分形式的质量守恒方程</h4><p><img src="/../images/1713516848847.png" alt="1713516848847"></p><p><img src="/../images/1713517551714.png" alt="1713517551714"></p><h4 id="散度和梯度"><a href="#散度和梯度" class="headerlink" title="散度和梯度"></a>散度和梯度</h4><p><img src="/../images/1713517596596.png" alt="1713517596596"></p><p><img src="/../images/1713517639356.png" alt="1713517639356"></p><h4 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h4><p>定常流动：流动是稳定的，不随时间而改变</p><p><img src="/../images/1713518306247.png" alt="1713518306247"></p><p>不可压流动：ρ为常数</p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/1713518419990.png" alt="1713518419990"></h5><h4 id="连续方程微分形式的第二种推导方法"><a href="#连续方程微分形式的第二种推导方法" class="headerlink" title="连续方程微分形式的第二种推导方法"></a>连续方程微分形式的第二种推导方法</h4><p>略</p><p>散度的物理意义：</p><p><img src="/../images/1713520658383.png" alt="1713520658383"></p><p>速度散度：单位体积单位时间的体积变化</p><p><img src="/../images/1713520754996.png" alt="1713520754996"></p><h4 id="定常准一维流动的连续方程"><a href="#定常准一维流动的连续方程" class="headerlink" title="定常准一维流动的连续方程"></a>定常准一维流动的连续方程</h4><p>ρuA&#x3D;常数</p><p><img src="/../images/1713522073052.png" alt="1713522073052"></p><h3 id="动量守恒方程"><a href="#动量守恒方程" class="headerlink" title="动量守恒方程"></a>动量守恒方程</h3><h3 id="能量守恒方程"><a href="#能量守恒方程" class="headerlink" title="能量守恒方程"></a>能量守恒方程</h3>]]></content>
    
    
    <categories>
      
      <category>cfd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cfd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_github遇到的问题</title>
    <link href="/2024/06/28/hexo_github%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/06/28/hexo_github%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="冒号后面要加空格"><a href="#冒号后面要加空格" class="headerlink" title="冒号后面要加空格"></a>冒号后面要加空格</h3><h3 id="repo写以下格式"><a href="#repo写以下格式" class="headerlink" title="repo写以下格式"></a>repo写以下格式</h3><p><img src="/../images/1719557282413.png"></p><h3 id="master分支设置"><a href="#master分支设置" class="headerlink" title="master分支设置"></a>master分支设置</h3><p><img src="/../images/1719557364439.png"></p><p><img src="/../images/1719557376929.png"></p>]]></content>
    
    
    <categories>
      
      <category>喜欢捣鼓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加载图片，研究一下</title>
    <link href="/2024/06/28/%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
    <url>/2024/06/28/%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/a.jpeg" alt="车"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/25/hello-world/"/>
    <url>/2024/06/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
